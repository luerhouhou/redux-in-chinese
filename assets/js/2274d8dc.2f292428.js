"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[290],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return m}});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=c(a),m=o,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||s;return a?n.createElement(h,r(r({ref:t},d),{},{components:a})):n.createElement(h,r({ref:t},d))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=a.length,r=new Array(s);r[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var c=2;c<s;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},3892:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return p}});var n=a(7462),o=a(3366),s=(a(7294),a(3905)),r=["components"],i={id:"deriving-data-selectors",title:"Deriving Data with Selectors",description:"Usage > Redux Logic > Selectors: deriving data from the Redux state"},l=void 0,c={unversionedId:"usage/deriving-data-selectors",id:"usage/deriving-data-selectors",title:"Deriving Data with Selectors",description:"Usage > Redux Logic > Selectors: deriving data from the Redux state",source:"@site/../docs/usage/deriving-data-selectors.md",sourceDirName:"usage",slug:"/usage/deriving-data-selectors",permalink:"/usage/deriving-data-selectors",draft:!1,tags:[],version:"current",frontMatter:{id:"deriving-data-selectors",title:"Deriving Data with Selectors",description:"Usage > Redux Logic > Selectors: deriving data from the Redux state"},sidebar:"docs",previous:{title:"\u51cf\u5c11\u6837\u677f\u4ee3\u7801",permalink:"/usage/reducing-boilerplate"},next:{title:"Writing Logic with Thunks",permalink:"/usage/writing-logic-thunks"}},d={},p=[{value:"Deriving Data",id:"deriving-data",level:2},{value:"Calculating Derived Data with Selectors",id:"calculating-derived-data-with-selectors",level:2},{value:"Basic Selector Concepts",id:"basic-selector-concepts",level:3},{value:"Encapsulating State Shape with Selectors",id:"encapsulating-state-shape-with-selectors",level:3},{value:"Optimizing Selectors with Memoization",id:"optimizing-selectors-with-memoization",level:3},{value:"Writing Memoized Selectors with Reselect",id:"writing-memoized-selectors-with-reselect",level:2},{value:"<code>createSelector</code> Overview",id:"createselector-overview",level:3},{value:"<code>createSelector</code> Behavior",id:"createselector-behavior",level:3},{value:"Reselect Usage Patterns and Limitations",id:"reselect-usage-patterns-and-limitations",level:3},{value:"Nesting Selectors",id:"nesting-selectors",level:4},{value:"Passing Input Parameters",id:"passing-input-parameters",level:4},{value:"Selector Factories",id:"selector-factories",level:4},{value:"Alternative Selector Libraries",id:"alternative-selector-libraries",level:2},{value:"<code>proxy-memoize</code>",id:"proxy-memoize",level:3},{value:"<code>re-reselect</code>",id:"re-reselect",level:3},{value:"<code>reselect-tools</code>",id:"reselect-tools",level:3},{value:"<code>redux-views</code>",id:"redux-views",level:3},{value:"Reselect v5 Proposal",id:"reselect-v5-proposal",level:3},{value:"Using Selectors with React-Redux",id:"using-selectors-with-react-redux",level:2},{value:"Calling Selectors with Parameters",id:"calling-selectors-with-parameters",level:3},{value:"Creating Unique Selector Instances",id:"creating-unique-selector-instances",level:3},{value:"Using Selectors Effectively",id:"using-selectors-effectively",level:2},{value:"Define Selectors Alongside Reducers",id:"define-selectors-alongside-reducers",level:3},{value:"Balance Selector Usage",id:"balance-selector-usage",level:3},{value:"Reshape State as Needed for Components",id:"reshape-state-as-needed-for-components",level:3},{value:"Globalize Selectors if Needed",id:"globalize-selectors-if-needed",level:3},{value:"Further Information",id:"further-information",level:2}],u={toc:p};function m(e){var t=e.components,a=(0,o.Z)(e,r);return(0,s.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"What You'll Learn")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("ul",{parentName:"div"},(0,s.kt)("li",{parentName:"ul"},"Why good Redux architecture keeps state minimal and derives additional data"),(0,s.kt)("li",{parentName:"ul"},"Principles of using selector functions to derive data and encapsulate lookups"),(0,s.kt)("li",{parentName:"ul"},"How to use the Reselect library to write memoized selectors for optimization"),(0,s.kt)("li",{parentName:"ul"},"Advanced techniques for using Reselect"),(0,s.kt)("li",{parentName:"ul"},"Additional tools and libraries for creating selectors"),(0,s.kt)("li",{parentName:"ul"},"Best practices for writing selectors")))),(0,s.kt)("h2",{id:"deriving-data"},"Deriving Data"),(0,s.kt)("p",null,"We specifically recommend that Redux apps should ",(0,s.kt)("a",{parentName:"p",href:"/style-guide/#keep-state-minimal-and-derive-additional-values"},"keep the Redux state minimal, and derive additional values from that state whenever possible"),"."),(0,s.kt)("p",null,"This includes things like calculating filtered lists or summing up values. As an example, a todo app would keep an original list of todo objects in state, but derive a filtered list of todos outside the state whenever the state is updated. Similarly, a check for whether all todos have been completed, or number of todos remaining, can be calculated outside the store as well."),(0,s.kt)("p",null,"This has several benefits:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The actual state is easier to read"),(0,s.kt)("li",{parentName:"ul"},"Less logic is needed to calculate those additional values and keep them in sync with the rest of the data"),(0,s.kt)("li",{parentName:"ul"},"The original state is still there as a reference and isn't being replaced")),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"This is ",(0,s.kt)("em",{parentName:"p"},"also")," a good principle for React state as well! Many times users tried to define a ",(0,s.kt)("inlineCode",{parentName:"p"},"useEffect")," hook that waits for a state value to change, and then sets state with some derived value like ",(0,s.kt)("inlineCode",{parentName:"p"},"setAllCompleted(allCompleted)"),". Instead, that value can be derived during the rendering process and used directly, without having to save the value into state at all:"),(0,s.kt)("pre",{parentName:"div"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"function TodoList() {\n  const [todos, setTodos] = useState([])\n\n  // highlight-start\n  // Derive the data while rendering\n  const allTodosCompleted = todos.every(todo => todo.completed)\n  // highlight-end\n\n  // render with this value\n}\n")))),(0,s.kt)("h2",{id:"calculating-derived-data-with-selectors"},"Calculating Derived Data with Selectors"),(0,s.kt)("p",null,"In a typical Redux application, the logic for deriving data is usually written as functions we call ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("em",{parentName:"strong"},"selectors")),"."),(0,s.kt)("p",null,"Selectors are primarily used to encapsulate logic for looking up specific values from state, logic for actually deriving values, and improving performance by avoiding unnecessary recalculations."),(0,s.kt)("p",null,"You are not ",(0,s.kt)("em",{parentName:"p"},"required")," to use selectors for all state lookups, but they are a standard pattern and widely used."),(0,s.kt)("h3",{id:"basic-selector-concepts"},"Basic Selector Concepts"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},'A "selector function" is any function that accepts the Redux store state (or part of the state) as an argument, and returns data that is based on that state.')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Selectors don't have to be written using a special library"),", and it doesn't matter whether you write them as arrow functions or the ",(0,s.kt)("inlineCode",{parentName:"p"},"function")," keyword. For example, all of these are valid selector functions:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// Arrow function, direct lookup\nconst selectEntities = state => state.entities\n\n// Function declaration, mapping over an array to derive values\nfunction selectItemIds(state) {\n  return state.items.map(item => item.id)\n}\n\n// Function declaration, encapsulating a deep lookup\nfunction selectSomeSpecificField(state) {\n  return state.some.deeply.nested.field\n}\n\n// Arrow function, deriving values from an array\nconst selectItemsWhoseNamesStartWith = (items, namePrefix) =>\n  items.filter(item => item.name.startsWith(namePrefix))\n")),(0,s.kt)("p",null,"A selector function can have any name you want. However, ",(0,s.kt)("a",{parentName:"p",href:"/style-guide/#name-selector-functions-as-selectthing"},(0,s.kt)("strong",{parentName:"a"},"we recommend prefixing selector function names with the word ",(0,s.kt)("inlineCode",{parentName:"strong"},"select")," combined with a description of the value being selected")),". Typical examples of this would look like ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"selectTodoById")),", ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"selectFilteredTodos")),", and ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"selectVisibleTodos")),"."),(0,s.kt)("p",null,"If you've used ",(0,s.kt)("a",{parentName:"p",href:"/tutorials/fundamentals/part-5-ui-react"},"the ",(0,s.kt)("inlineCode",{parentName:"a"},"useSelector")," hook from React-Redux"),", you're probably already familiar with the basic idea of a selector function - the functions that we pass to ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector")," must be selectors:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"function TodoList() {\n  // highlight-start\n  // This anonymous arrow function is a selector!\n  const todos = useSelector(state => state.todos)\n  // highlight-end\n}\n")),(0,s.kt)("p",null,"Selector functions are typically defined in two different parts of a Redux application:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"In slice files, alongside the reducer logic"),(0,s.kt)("li",{parentName:"ul"},"In component files, either outside the component, or inline in ",(0,s.kt)("inlineCode",{parentName:"li"},"useSelector")," calls")),(0,s.kt)("p",null,"A selector function can be used anywhere you have access to the entire Redux root state value. This includes the ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector")," hook, the ",(0,s.kt)("inlineCode",{parentName:"p"},"mapState")," function for ",(0,s.kt)("inlineCode",{parentName:"p"},"connect"),", middleware, thunks, and sagas. For example, thunks and middleware have access to the ",(0,s.kt)("inlineCode",{parentName:"p"},"getState")," argument, so you can call a selector there:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"function addTodosIfAllowed(todoText) {\n  return (dispatch, getState) => {\n    const state = getState()\n    const canAddTodos = selectCanAddTodos(state)\n\n    if (canAddTodos) {\n      dispatch(todoAdded(todoText))\n    }\n  }\n}\n")),(0,s.kt)("p",null,"It's not typically possible to use selectors inside of reducers, because a slice reducer only has access to its own slice of the Redux state, and most selectors expect to be given the ",(0,s.kt)("em",{parentName:"p"},"entire")," Redux root state as an argument."),(0,s.kt)("h3",{id:"encapsulating-state-shape-with-selectors"},"Encapsulating State Shape with Selectors"),(0,s.kt)("p",null,"The first reason to use selector functions is for encapsulation and reusability when dealing with your Redux state shape."),(0,s.kt)("p",null,"Let's say that one of your ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector")," hooks makes a very specific lookup into part of your Redux state:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const data = useSelector(state => state.some.deeply.nested.field)\n")),(0,s.kt)("p",null,"That is legal code, and will run fine. But, it might not be the best idea architecturally. Imagine that you've got several components that need to access that field. What happens if you need to make a change to where that piece of state lives? You would now have to go change ",(0,s.kt)("em",{parentName:"p"},"every")," ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector")," hook that references that value. So, in the same way that ",(0,s.kt)("a",{parentName:"p",href:"/style-guide/#use-action-creators"},"we recommend using action creators to encapsulate details of creating actions"),", we recommend defining reusable selectors to encapsulate the knowledge of where a given piece of state lives. Then, you can use a given selector function many times in the codebase, anywhere that your app needs to retrieve that particular data."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Ideally, only your reducer functions and selectors should know the exact state structure, so if you change where some state lives, you would only need to update those two pieces of logic"),"."),(0,s.kt)("p",null,"Because of this, it's often a good idea to define reusable selectors directly inside slice files, rather than always defining them inside of a component."),(0,s.kt)("p",null,"One common description of selectors is that they're like ",(0,s.kt)("strong",{parentName:"p"},'"queries into your state"'),". You don't care about exactly how the query came up with the data you needed, just that you asked for the data and got back a result."),(0,s.kt)("h3",{id:"optimizing-selectors-with-memoization"},"Optimizing Selectors with Memoization"),(0,s.kt)("p",null,'Selector functions often need to perform relatively "expensive" calculations, or create derived values that are new object and array references. This can be a concern for application performance, for several reasons:'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Selectors used with ",(0,s.kt)("inlineCode",{parentName:"li"},"useSelector")," or ",(0,s.kt)("inlineCode",{parentName:"li"},"mapState")," will be re-run after every dispatched action, regardless of what section of the Redux root state was actually updated. Re-running expensive calculations when the input state sections didn't change is a waste of CPU time, and it's very likely that the inputs won't have changed most of the time anyway."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"useSelector")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"mapState")," rely on ",(0,s.kt)("inlineCode",{parentName:"li"},"===")," reference equality checks of the return values to determine if the component needs to re-render. If a selector ",(0,s.kt)("em",{parentName:"li"},"always")," returns new references, it will force the component to re-render even if the derived data is effectively the same as last time. This is especially common with array operations like ",(0,s.kt)("inlineCode",{parentName:"li"},"map()")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"filter()"),", which return new array references.")),(0,s.kt)("p",null,"As an example, this component is written badly, because its ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector")," call ",(0,s.kt)("em",{parentName:"p"},"always")," returns a new array reference. That means the component will re-render after ",(0,s.kt)("em",{parentName:"p"},"every")," dispatched action, even if the input ",(0,s.kt)("inlineCode",{parentName:"p"},"state.todos")," slice hasn't changed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"function TodoList() {\n  // highlight-start\n  // \u274c WARNING: this _always_ returns a new reference, so it will _always_ re-render!\n  const completedTodos = useSelector(state =>\n    state.todos.map(todo => todo.completed)\n  )\n  // highlight-end\n}\n")),(0,s.kt)("p",null,'Another example is a component that needs to do some "expensive" work to transform data:'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"function ExampleComplexComponent() {\n  const data = useSelector(state => {\n    const initialData = state.data\n    const filteredData = expensiveFiltering(initialData)\n    const sortedData = expensiveSorting(filteredData)\n    const transformedData = expensiveTransformation(sortedData)\n\n    return transformedData\n  })\n}\n")),(0,s.kt)("p",null,'Similarly, this "expensive" logic will re-run after ',(0,s.kt)("em",{parentName:"p"},"every")," dispatched action. Not only will it probably create new references, but it's work that doesn't need to be done unless ",(0,s.kt)("inlineCode",{parentName:"p"},"state.data")," actually changes."),(0,s.kt)("p",null,"Because of this, we need a way to write optimized selectors that can avoid recalculating results if the same inputs are passed in. This is where the idea of ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("em",{parentName:"strong"},"memoization"))," comes in."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Memoization is a form of caching"),". It involves tracking inputs to a function, and storing the inputs and the results for later reference. If a function is called with the same inputs as before, the function can skip doing the actual work, and return the same result it generated the last time it received those input values. This optimizes performance by only doing work if inputs have changed, and consistently returning the same result references if the inputs are the same."),(0,s.kt)("p",null,"Next, we'll look at some options for writing memoized selectors."),(0,s.kt)("h2",{id:"writing-memoized-selectors-with-reselect"},"Writing Memoized Selectors with Reselect"),(0,s.kt)("p",null,"The Redux ecosystem has traditionally used a library called ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/reselect"},(0,s.kt)("strong",{parentName:"a"},"Reselect"))," to create memoized selector functions. There also are other similar libraries, as well as multiple variations and wrappers around Reselect - we'll look at those later."),(0,s.kt)("h3",{id:"createselector-overview"},(0,s.kt)("inlineCode",{parentName:"h3"},"createSelector")," Overview"),(0,s.kt)("p",null,"Reselect provides a function called ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc"},(0,s.kt)("inlineCode",{parentName:"a"},"createSelector"))," to generate memoized selectors. ",(0,s.kt)("inlineCode",{parentName:"p"},"createSelector"),' accepts one or more "input selector" functions, plus an "output selector" function, and returns a new selector function for you to use.'),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"createSelector")," is included as part of ",(0,s.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org"},"our official Redux Toolkit package"),", and is re-exported for ease of use."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"createSelector")," can accept multiple input selectors, which can be provided as separate arguments or as an array. The results from all the input selectors are provided as separate arguments to the output selector:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const selectA = state => state.a\nconst selectB = state => state.b\nconst selectC = state => state.c\n\nconst selectABC = createSelector([selectA, selectB, selectC], (a, b, c) => {\n  // do something with a, b, and c, and return a result\n  return a + b + c\n})\n\n// Call the selector function and get a result\nconst abc = selectABC(state)\n\n// could also be written as separate arguments, and works exactly the same\nconst selectABC2 = createSelector(selectA, selectB, selectC, (a, b, c) => {\n  // do something with a, b, and c, and return a result\n  return a + b + c\n})\n")),(0,s.kt)("p",null,"When you call the selector, Reselect will run your input selectors with all of the arguments you gave, and looks at the returned values. If any of the results are ",(0,s.kt)("inlineCode",{parentName:"p"},"===")," different than before, it will re-run the output selector, and pass in those results as the arguments. If all of the results are the same as the last time, it will skip re-running the output selector, and just return the cached final result from before."),(0,s.kt)("p",null,"This means that ",(0,s.kt)("strong",{parentName:"p"},'"input selectors" should usually just extract and return values, and the "output selector" should do the transformation work'),"."),(0,s.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},'A somewhat common mistake is to write an "input selector" that extracts a value or does some derivation, and an "output selector" that just returns its result:'),(0,s.kt)("pre",{parentName:"div"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// \u274c BROKEN: this will not memoize correctly, and does nothing useful!\nconst brokenSelector = createSelector(\n  state => state.todos,\n  todos => todos\n)\n")),(0,s.kt)("p",{parentName:"div"},(0,s.kt)("strong",{parentName:"p"},'Any "output selector" that just returns its inputs is incorrect!')," The output selector should always have the transformation logic."),(0,s.kt)("p",{parentName:"div"},"Similarly, a memoized selector should ",(0,s.kt)("em",{parentName:"p"},"never")," use ",(0,s.kt)("inlineCode",{parentName:"p"},"state => state")," as an input! That will force the selector to always recalculate."))),(0,s.kt)("p",null,'In typical Reselect usage, you write your top-level "input selectors" as plain functions, and use ',(0,s.kt)("inlineCode",{parentName:"p"},"createSelector")," to create memoized selectors that look up nested values:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const state = {\n  a: {\n    first: 5\n  },\n  b: 10\n}\n\nconst selectA = state => state.a\nconst selectB = state => state.b\n\nconst selectA1 = createSelector([selectA], a => a.first)\n\nconst selectResult = createSelector([selectA1, selectB], (a1, b) => {\n  console.log('Output selector running')\n  return a1 + b\n})\n\nconst result = selectResult(state)\n// Log: \"Output selector running\"\nconsole.log(result)\n// 15\n\nconst secondResult = selectResult(state)\n// No log output\nconsole.log(secondResult)\n// 15\n")),(0,s.kt)("p",null,"Note that the second time we called ",(0,s.kt)("inlineCode",{parentName:"p"},"selectResult"),', the "output selector" didn\'t execute. Because the results of ',(0,s.kt)("inlineCode",{parentName:"p"},"selectA1")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"selectB")," were the same as the first call, ",(0,s.kt)("inlineCode",{parentName:"p"},"selectResult")," was able to return the memoized result from the first call."),(0,s.kt)("h3",{id:"createselector-behavior"},(0,s.kt)("inlineCode",{parentName:"h3"},"createSelector")," Behavior"),(0,s.kt)("p",null,"It's important to note that by default, ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"createSelector")," only memoizes the most recent set of parameters"),". That means that if you call a selector repeatedly with different inputs, it will still return a result, but it will have to keep re-running the output selector to produce the result:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const a = someSelector(state, 1) // first call, not memoized\nconst b = someSelector(state, 1) // same inputs, memoized\nconst c = someSelector(state, 2) // different inputs, not memoized\nconst d = someSelector(state, 1) // different inputs from last time, not memoized\n")),(0,s.kt)("p",null,"Also, you can pass multiple arguments into a selector. Reselect will call all of the input selectors with those exact inputs:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const selectItems = state => state.items\nconst selectItemId = (state, itemId) => itemId\n\nconst selectItemById = createSelector(\n  [selectItems, selectItemId],\n  (items, itemId) => items[itemId]\n)\n\nconst item = selectItemById(state, 42)\n\n/*\nInternally, Reselect does something like this:\n\nconst firstArg = selectItems(state, 42);  \nconst secondArg = selectItemId(state, 42);  \n  \nconst result = outputSelector(firstArg, secondArg);  \nreturn result;  \n*/\n")),(0,s.kt)("p",null,"Because of this, ",(0,s.kt)("strong",{parentName:"p"},'it\'s important that all of the "input selectors" you provide should accept the same types of parameters'),". Otherwise, the selectors will break."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const selectItems = state => state.items\n\n// expects a number as the second argument\nconst selectItemId = (state, itemId) => itemId\n\n// expects an object as the second argument\nconst selectOtherField = (state, someObject) => someObject.someField\n\nconst selectItemById = createSelector(\n  [selectItems, selectItemId, selectOtherField],\n  (items, itemId, someField) => items[itemId]\n)\n")),(0,s.kt)("p",null,"In this example, ",(0,s.kt)("inlineCode",{parentName:"p"},"selectItemId")," expects that its second argument will be some simple value, while ",(0,s.kt)("inlineCode",{parentName:"p"},"selectOtherField")," expects that the second argument is an object. If you call ",(0,s.kt)("inlineCode",{parentName:"p"},"selectItemById(state, 42)"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"selectOtherField")," will break because it's trying to access ",(0,s.kt)("inlineCode",{parentName:"p"},"42.someField"),"."),(0,s.kt)("h3",{id:"reselect-usage-patterns-and-limitations"},"Reselect Usage Patterns and Limitations"),(0,s.kt)("h4",{id:"nesting-selectors"},"Nesting Selectors"),(0,s.kt)("p",null,"It's possible to take selectors generated with ",(0,s.kt)("inlineCode",{parentName:"p"},"createSelector"),", and use them as inputs for other selectors as well. In this example, the ",(0,s.kt)("inlineCode",{parentName:"p"},"selectCompletedTodos")," selector is used as an input to ",(0,s.kt)("inlineCode",{parentName:"p"},"selectCompletedTodoDescriptions"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const selectTodos = state => state.todos\n\nconst selectCompletedTodos = createSelector([selectTodos], todos =>\n  todos.filter(todo => todo.completed)\n)\n\nconst selectCompletedTodoDescriptions = createSelector(\n  [selectCompletedTodos],\n  completedTodos => completedTodos.map(todo => todo.text)\n)\n")),(0,s.kt)("h4",{id:"passing-input-parameters"},"Passing Input Parameters"),(0,s.kt)("p",null,"A Reselect-generated selector function can be called with as many arguments as you want: ",(0,s.kt)("inlineCode",{parentName:"p"},"selectThings(a, b, c, d, e)"),'. However, what matters for re-running the output is not the number of arguments, or whether the arguments themselves have changed to be new references. Instead, it\'s about the "input selectors" that were defined, and whether ',(0,s.kt)("em",{parentName:"p"},"their"),' results have changed. Similarly, the arguments for the "output selector" are solely based on what the input selectors return.'),(0,s.kt)("p",null,"This means that if you want to pass additional parameters through to the output selector, you must define input selectors that extract those values from the original selector arguments:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const selectItemsByCategory = createSelector(\n  [\n    // Usual first input - extract value from `state`\n    state => state.items,\n    // Take the second arg, `category`, and forward to the output selector\n    (state, category) => category\n  ],\n  // Output selector gets (`items, category)` as args\n  (items, category) => items.filter(item => item.category === category)\n)\n")),(0,s.kt)("p",null,"For consistency, you may want to consider passing additional parameters to a selector as a single object, such as ",(0,s.kt)("inlineCode",{parentName:"p"},"selectThings(state, otherArgs)"),", and then extracting values from the ",(0,s.kt)("inlineCode",{parentName:"p"},"otherArgs")," object."),(0,s.kt)("h4",{id:"selector-factories"},"Selector Factories"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"createSelector")," only has a default cache size of 1, and this is per each unique instance of a selector"),". This creates problems when a single selector function needs to get reused in multiple places with differing inputs."),(0,s.kt)("p",null,'One option is to create a "selector factory" - a function that runs ',(0,s.kt)("inlineCode",{parentName:"p"},"createSelector()")," and generates a new unique selector instance every time it's called:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const makeSelectItemsByCategory = () => {\n  const selectItemsByCategory = createSelector(\n    [state => state.items, (state, category) => category],\n    (items, category) => items.filter(item => item.category === category)\n  )\n  return selectItemsByCategory\n}\n")),(0,s.kt)("p",null,"This is particularly useful when multiple similar UI components need to derive different subsets of the data based on props."),(0,s.kt)("h2",{id:"alternative-selector-libraries"},"Alternative Selector Libraries"),(0,s.kt)("p",null,"While Reselect is the most widely used selector library with Redux, there are many other libraries that solve similar problems, or expand on Reselect's capabilities."),(0,s.kt)("h3",{id:"proxy-memoize"},(0,s.kt)("inlineCode",{parentName:"h3"},"proxy-memoize")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"proxy-memoize")," is a relatively new memoized selector library that uses a unique implementation approach. It relies on ES6 ",(0,s.kt)("inlineCode",{parentName:"p"},"Proxy")," objects to track attempted reads of nested values, then compares only the nested values on later calls to see if they've changed. This can provide better results than Reselect in some cases."),(0,s.kt)("p",null,"A good example of this is a selector that derives an array of todo descriptions:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { createSelector } from 'reselect'\n\nconst selectTodoDescriptionsReselect = createSelector(\n  [state => state.todos],\n  todos => todos.map(todo => todo.text)\n)\n")),(0,s.kt)("p",null,"Unfortunately, this will recalculate the derived array if any other value inside of ",(0,s.kt)("inlineCode",{parentName:"p"},"state.todos")," changes, such as toggling a ",(0,s.kt)("inlineCode",{parentName:"p"},"todo.completed")," flag. The ",(0,s.kt)("em",{parentName:"p"},"contents")," of the derived array are identical, but because the input ",(0,s.kt)("inlineCode",{parentName:"p"},"todos")," array changed, it has to calculate a new output array, and that has a new reference."),(0,s.kt)("p",null,"The same selector with ",(0,s.kt)("inlineCode",{parentName:"p"},"proxy-memoize")," might look like:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import memoize from 'proxy-memoize'\n\nconst selectTodoDescriptionsProxy = memoize(state =>\n  state.todos.map(todo => todo.text)\n)\n")),(0,s.kt)("p",null,"Unlike Reselect, ",(0,s.kt)("inlineCode",{parentName:"p"},"proxy-memoize")," can detect that only the ",(0,s.kt)("inlineCode",{parentName:"p"},"todo.text")," fields are being accessed, and will only recalculate the rest if one of the ",(0,s.kt)("inlineCode",{parentName:"p"},"todo.text")," fields changed."),(0,s.kt)("p",null,"It also has a built-in ",(0,s.kt)("inlineCode",{parentName:"p"},"size")," option, which lets you set the desired cache size for a single selector instance."),(0,s.kt)("p",null,"It has some tradeoffs and differences from Reselect:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"All values are passed in as a single object argument"),(0,s.kt)("li",{parentName:"ul"},"It requires that the environment supports ES6 ",(0,s.kt)("inlineCode",{parentName:"li"},"Proxy")," objects (no IE11)"),(0,s.kt)("li",{parentName:"ul"},"It's more magical, whereas Reselect is more explicit"),(0,s.kt)("li",{parentName:"ul"},"There are some edge cases regarding the ",(0,s.kt)("inlineCode",{parentName:"li"},"Proxy"),"-based tracking behavior"),(0,s.kt)("li",{parentName:"ul"},"It's newer and less widely used")),(0,s.kt)("p",null,"All that said, ",(0,s.kt)("strong",{parentName:"p"},"we officially encourage considering using ",(0,s.kt)("inlineCode",{parentName:"strong"},"proxy-memoize")," as a viable alternative to Reselect"),"."),(0,s.kt)("h3",{id:"re-reselect"},(0,s.kt)("inlineCode",{parentName:"h3"},"re-reselect")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/toomuchdesign/re-reselect"},"https://github.com/toomuchdesign/re-reselect"),' improves Reselect\'s caching behavior, by allowing you to define a "key selector". This is used to manage multiple instances of Reselect selectors internally, which can help simplify usage across multiple components.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { createCachedSelector } from 're-reselect'\n\nconst getUsersByLibrary = createCachedSelector(\n  // inputSelectors\n  getUsers,\n  getLibraryId,\n\n  // resultFunc\n  (users, libraryId) => expensiveComputation(users, libraryId)\n)(\n  // re-reselect keySelector (receives selectors' arguments)\n  // Use \"libraryName\" as cacheKey\n  (_state_, libraryName) => libraryName\n)\n")),(0,s.kt)("h3",{id:"reselect-tools"},(0,s.kt)("inlineCode",{parentName:"h3"},"reselect-tools")),(0,s.kt)("p",null,"Sometimes it can be hard to trace how multiple Reselect selectors relate to each other, and what caused a selector to recalculate. ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/skortchmark9/reselect-tools"},"https://github.com/skortchmark9/reselect-tools")," provides a way to trace selector dependencies, and its own DevTools to help visualize those relationships and check selector values."),(0,s.kt)("h3",{id:"redux-views"},(0,s.kt)("inlineCode",{parentName:"h3"},"redux-views")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/josepot/redux-views"},"https://github.com/josepot/redux-views")," is similar to ",(0,s.kt)("inlineCode",{parentName:"p"},"re-reselect"),", in that it provides a way to select unique keys for each item for consistent caching. It was designed as a near-drop-in replacement for Reselect, and actually proposed as an option for a potential Reselect version 5."),(0,s.kt)("h3",{id:"reselect-v5-proposal"},"Reselect v5 Proposal"),(0,s.kt)("p",null,"We've opened up a roadmap discussion in the Reselect repo to figure out potential enhancements to a future version of Reselect, such as improving the API to better support larger cache sizes, rewriting the codebase in TypeScript, and other possible improvements. We'd welcome additional community feedback in that discussion:"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/reselect/discussions/491"},(0,s.kt)("strong",{parentName:"a"},"Reselect v5 Roadmap Discussion: Goals and API Design"))),(0,s.kt)("h2",{id:"using-selectors-with-react-redux"},"Using Selectors with React-Redux"),(0,s.kt)("h3",{id:"calling-selectors-with-parameters"},"Calling Selectors with Parameters"),(0,s.kt)("p",null,"It's common to want to pass additional arguments to a selector function. However, ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector")," always calls the provided selector function with one argument - the Redux root ",(0,s.kt)("inlineCode",{parentName:"p"},"state"),"."),(0,s.kt)("p",null,"The simplest solution is to pass an anonymous selector to ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector"),", and then immediately call the real selector with both ",(0,s.kt)("inlineCode",{parentName:"p"},"state")," and any additional arguments:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { selectTodoById } from './todosSlice'\n\nfunction TodoListitem({ todoId }) {\n  // highlight-start\n  // Captures `todoId` from scope, gets `state` as an arg, and forwards both\n  // to the actual selector function to extract the result\n  const todo = useSelector(state => selectTodoById(state, todoId))\n  // highlight-end\n}\n")),(0,s.kt)("h3",{id:"creating-unique-selector-instances"},"Creating Unique Selector Instances"),(0,s.kt)("p",null,"There are many cases where a selector function needs to be reused across multiple components. If the components will all be calling the selector with different arguments, it will break memoization - the selector never sees the same arguments multiple times in a row, and thus can never return a cached value."),(0,s.kt)("p",null,"The standard approach here is to create a unique instance of a memoized selector in the component, and then use that with ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector"),". That allows each component to consistently pass the same arguments to its own selector instance, and that selector can correctly memoize the results."),(0,s.kt)("p",null,"For function components, this is normally done with ",(0,s.kt)("inlineCode",{parentName:"p"},"useMemo")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"useCallback"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { makeSelectItemsByCategory } from './categoriesSlice'\n\nfunction CategoryList({ category }) {\n  // Create a new memoized selector, for each component instance, on mount\n  const selectItemsByCategory = useMemo(makeSelectItemsByCategory, [])\n\n  const itemsByCategory = useSelector(state =>\n    selectItemsByCategory(state, category)\n  )\n}\n")),(0,s.kt)("p",null,"For class components with ",(0,s.kt)("inlineCode",{parentName:"p"},"connect"),', this can be done with an advanced "factory function" syntax for ',(0,s.kt)("inlineCode",{parentName:"p"},"mapState"),". If the ",(0,s.kt)("inlineCode",{parentName:"p"},"mapState")," function returns a new function on its first call, that will be used as the real ",(0,s.kt)("inlineCode",{parentName:"p"},"mapState")," function. This provides a closure where you can create a new selector instance:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { makeSelectItemsByCategory } from './categoriesSlice'\n\nconst makeMapState = (state, ownProps) => {\n  // Closure - create a new unique selector instance here,\n  // and this will run once for every component instance\n  const selectItemsByCategory = makeSelectItemsByCategory()\n\n  const realMapState = (state, ownProps) => {\n    return {\n      itemsByCategory: selectItemsByCategory(state, ownProps.category)\n    }\n  }\n\n  // Returning a function here will tell `connect` to use it as\n  // `mapState` instead of the original one given to `connect`\n  return realMapState\n}\n\nexport default connect(makeMapState)(CategoryList)\n")),(0,s.kt)("h2",{id:"using-selectors-effectively"},"Using Selectors Effectively"),(0,s.kt)("p",null,"While selectors are a common pattern in Redux applications, they are often misused or misunderstood. Here are some guidelines for using selector functions correctly."),(0,s.kt)("h3",{id:"define-selectors-alongside-reducers"},"Define Selectors Alongside Reducers"),(0,s.kt)("p",null,"Selector functions are often defined in the UI layer, directly inside of ",(0,s.kt)("inlineCode",{parentName:"p"},"useSelector")," calls. However, this means that there can be repetition between selectors defined in different files, and the functions are anonymous."),(0,s.kt)("p",null,"Like any other function, you can extract an anonymous function outside the component to give it a name:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// highlight-next-line\nconst selectTodos = state => state.todos\n\nfunction TodoList() {\n  // highlight-next-line\n  const todos = useSelector(selectTodos)\n}\n")),(0,s.kt)("p",null,"However, multiple parts of the application may want to use the same lookups. Also, conceptually, we may want to keep the knowledge of how the ",(0,s.kt)("inlineCode",{parentName:"p"},"todos")," state is organized as an implementation detail inside the ",(0,s.kt)("inlineCode",{parentName:"p"},"todosSlice")," file, so that it's all in one place."),(0,s.kt)("p",null,"Because of this, ",(0,s.kt)("strong",{parentName:"p"},"it's a good idea to define reusable selectors alongside their corresponding reducers"),". In this case, we could export ",(0,s.kt)("inlineCode",{parentName:"p"},"selectTodos")," from the ",(0,s.kt)("inlineCode",{parentName:"p"},"todosSlice")," file:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"import { createSlice } from '@reduxjs/toolkit'\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState: [],\n  reducers: {\n    todoAdded(state, action) {\n      state.push(action.payload)\n    }\n  }\n})\n\nexport const { todoAdded } = todosSlice.actions\nexport default todosSlice.reducer\n\n// highlight-start\n// Export a reusable selector here\nexport const selectTodos = state => state.todos\n// highlight-end\n")),(0,s.kt)("p",null,"That way, if we happen to make an update to the structure of the todos slice state, the relevant selectors are right here and can be updated at the same time, with minimal changes to any other parts of the app."),(0,s.kt)("h3",{id:"balance-selector-usage"},"Balance Selector Usage"),(0,s.kt)("p",null,"It's possible to add ",(0,s.kt)("em",{parentName:"p"},"too many")," selectors to an application. ",(0,s.kt)("strong",{parentName:"p"},"Adding a separate selector function for every single field is not a good idea!")," That ends up turning Redux into something resembling a Java class with getter/setter functions for every field. It's not going to ",(0,s.kt)("em",{parentName:"p"},"improve")," the code, and it's probably going to make the code ",(0,s.kt)("em",{parentName:"p"},"worse")," - maintaining all those extra selectors is a lot of additional effort, and it will be harder to trace what values are being used where."),(0,s.kt)("p",null,"Similarly, ",(0,s.kt)("strong",{parentName:"p"},"don't make every single selector memoized!"),". Memoization is only needed if you are truly ",(0,s.kt)("em",{parentName:"p"},"deriving")," results, ",(0,s.kt)("em",{parentName:"p"},"and")," if the derived results would likely create new references every time. ",(0,s.kt)("strong",{parentName:"p"},"A selector function that does a direct lookup and return of a value should be a plain function, not memoized"),"."),(0,s.kt)("p",null,"Some examples of when and when not to memoize:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// \u274c DO NOT memoize: will always return a consistent reference\nconst selectTodos = state => state.todos\nconst selectNestedValue = state => state.some.deeply.nested.field\nconst selectTodoById = (state, todoId) => state.todos[todoId]\n\n// \u274c DO NOT memoize: deriving data, but will return a consistent result\nconst selectItemsTotal = state => {\n  return state.items.reduce((result, item) => {\n    return result + item.total\n  }, 0)\n}\nconst selectAllCompleted = state => state.todos.every(todo => todo.completed)\n\n// \u2705 SHOULD memoize: returns new references when called\nconst selectTodoDescriptions = state => state.todos.map(todo => todo.text)\n")),(0,s.kt)("h3",{id:"reshape-state-as-needed-for-components"},"Reshape State as Needed for Components"),(0,s.kt)("p",null,"Selectors do not have to limit themselves to direct lookups - they can perform ",(0,s.kt)("em",{parentName:"p"},"any")," needed transformation logic inside. This is especially valuable to help prepare data that is needed by specific components."),(0,s.kt)("p",null,'A Redux state often has data in a "raw" form, because ',(0,s.kt)("a",{parentName:"p",href:"#deriving-data"},"the state should be kept minimal"),", and many components may need to present the same data differently. You can use selectors to not only ",(0,s.kt)("em",{parentName:"p"},"extract")," state, but to ",(0,s.kt)("em",{parentName:"p"},"reshape")," it as needed for this specific component's needs. That could include pulling data from multiple slices of the root state, extracting specific values, merging different pieces of the data together, or any other transformations that are helpful."),(0,s.kt)("p",null,"It's fine if a component has some of this logic too, but it can be beneficial to pull all of this transformation logic out into separate selectors for better reuse and testability."),(0,s.kt)("h3",{id:"globalize-selectors-if-needed"},"Globalize Selectors if Needed"),(0,s.kt)("p",null,"There's an inherent imbalance between writing slice reducers and selectors. Slice reducers only know about their one portion of the state - to the reducer, its ",(0,s.kt)("inlineCode",{parentName:"p"},"state")," is all that exists, such as the array of todos in a ",(0,s.kt)("inlineCode",{parentName:"p"},"todoSlice"),". Selectors, on the other hand, ",(0,s.kt)("em",{parentName:"p"},"usually")," are written to take the entire Redux root state as their argument. This means that they have to know where in the root state this slice's data is kept, such as ",(0,s.kt)("inlineCode",{parentName:"p"},"state.todos"),", even though that's not really defined until the root reducer is created (typically in the app-wide store setup logic)."),(0,s.kt)("p",null,"A typical slice file often has both of these patterns side-by-side. That's fine, especially in small or midsize apps. But, depending on your app's architecture, you may want to further abstract the selectors so that they ",(0,s.kt)("em",{parentName:"p"},"don't")," know where the slice state is kept - it has to be handed to them."),(0,s.kt)("p",null,'We refer to this pattern as "globalizing" selectors. A ',(0,s.kt)("strong",{parentName:"p"},'"globalized" selector')," is one that accepts the Redux root state as an argument, and knows how to find the relevant slice of state to perform the real logic. A ",(0,s.kt)("strong",{parentName:"p"},'"localized" selector')," is one that expects ",(0,s.kt)("em",{parentName:"p"},"just a piece")," of the state as an argument, without knowing or caring where that is in the root state:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'// "Globalized" - accepts root state, knows to find data at `state.todos`\nconst selectAllTodosCompletedGlobalized = state =>\n  state.todos.every(todo => todo.completed)\n\n// "Localized" - only accepts `todos` as argument, doesn\'t know where that came from\nconst selectAllTodosCompletedLocalized = todos =>\n  todos.every(todo => todo.completed)\n')),(0,s.kt)("p",null,'"Localized" selectors can be turned into "globalized" selectors by wrapping them in a function that knows how to retrieve the right slice of state and pass it onwards.'),(0,s.kt)("p",null,"Redux Toolkit's ",(0,s.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createEntityAdapter#selector-functions"},(0,s.kt)("inlineCode",{parentName:"a"},"createEntityAdapter")," API")," is an example of this pattern. If you call ",(0,s.kt)("inlineCode",{parentName:"p"},"todosAdapter.getSelectors()"),', with no argument, it returns a set of "localized" selectors that expect the ',(0,s.kt)("em",{parentName:"p"},"entity slice state")," as their argument. If you call ",(0,s.kt)("inlineCode",{parentName:"p"},"todosAdapter.getSelectors(state => state.todos)"),', it returns a set of "globalized" selectors that expect to be called with the ',(0,s.kt)("em",{parentName:"p"},"Redux root state")," as their argument."),(0,s.kt)("p",null,'There may also be other benefits to having "localized" versions of selectors as well. For example, say we have an advanced scenario of keeping multiple copies of ',(0,s.kt)("inlineCode",{parentName:"p"},"createEntityAdapter")," data nested in the store, such as a ",(0,s.kt)("inlineCode",{parentName:"p"},"chatRoomsAdapter")," that tracks rooms, and each room definition then has a ",(0,s.kt)("inlineCode",{parentName:"p"},"chatMessagesAdapter"),' state to store the messages. We can\'t directly look up the messages for each room - we first have to retrieve the room object, then select the messages out of that. This is easier if we have a set of "localized" selectors for the messages.'),(0,s.kt)("h2",{id:"further-information"},"Further Information"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Selector libraries:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Reselect: ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/reduxjs/reselect"},"https://github.com/reduxjs/reselect")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"proxy-memoize"),": ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/dai-shi/proxy-memoize"},"https://github.com/dai-shi/proxy-memoize")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"re-reselect"),": ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/toomuchdesign/re-reselect"},"https://github.com/toomuchdesign/re-reselect")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"reselect-tools"),": ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/skortchmark9/reselect-tools"},"https://github.com/skortchmark9/reselect-tools")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"redux-views"),": ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/josepot/redux-views"},"https://github.com/josepot/redux-views")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/reduxjs/reselect/discussions/491"},"Reselect v5 Roadmap Discussion: Goals and API Design")),(0,s.kt)("li",{parentName:"ul"},"Randy Coulman has an excellent series of blog posts on selector architecture and different approaches for globalizing Redux selectors, with tradeoffs:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://randycoulman.com/blog/2016/09/13/encapsulating-the-redux-state-tree/"},"Encapsulating the Redux State Tree")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://randycoulman.com/blog/2016/09/20/redux-reducer-selector-asymmetry/"},"Redux Reducer/Selector Asymmetry")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://randycoulman.com/blog/2016/09/27/modular-reducers-and-selectors/"},"Modular Reducers and Selectors")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://randycoulman.com/blog/2016/11/29/globalizing-redux-selectors/"},"Globalizing Redux Selectors")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://randycoulman.com/blog/2016/12/27/globalizing-curried-selectors/"},"Globalizing Curried Selectors")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://randycoulman.com/blog/2018/06/12/solving-circular-dependencies-in-modular-redux/"},"Solving Circular Dependencies in Modular Redux"))))))}m.isMDXComponent=!0}}]);