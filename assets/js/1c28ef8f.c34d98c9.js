"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1478],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},220:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={id:"writing-tests",title:"Writing Tests",description:"Usage > Writing Tests: recommended practices and setup for testing Redux apps"},l="Writing Tests",c={unversionedId:"usage/writing-tests",id:"usage/writing-tests",title:"Writing Tests",description:"Usage > Writing Tests: recommended practices and setup for testing Redux apps",source:"@site/../docs/usage/WritingTests.md",sourceDirName:"usage",slug:"/usage/writing-tests",permalink:"/usage/writing-tests",draft:!1,tags:[],version:"current",frontMatter:{id:"writing-tests",title:"Writing Tests",description:"Usage > Writing Tests: recommended practices and setup for testing Redux apps"}},p={},d=[{value:"Guiding Principles",id:"guiding-principles",level:2},{value:"Setting Up",id:"setting-up",level:2},{value:"Action Creators &amp; Thunks",id:"action-creators--thunks",level:2},{value:"Reducers",id:"reducers",level:2},{value:"Example",id:"example",level:4},{value:"Components",id:"components",level:2},{value:"Example",id:"example-1",level:4},{value:"Middleware",id:"middleware",level:2},{value:"Example",id:"example-2",level:4},{value:"Further Information",id:"further-information",level:2}],u={toc:d};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"writing-tests"},"Writing Tests"),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"What You'll Learn")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"Recommended practices for testing apps using Redux"),(0,i.kt)("li",{parentName:"ul"},"Examples of test configuration and setup")))),(0,i.kt)("h2",{id:"guiding-principles"},"Guiding Principles"),(0,i.kt)("p",null,"The guiding principles for testing Redux logic closely follow that of React Testing Library:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/kentcdodds/status/977018512689455106"},"The more your tests resemble the way your software is used, the more confidence they can give you.")," - Kent C. Dodds")),(0,i.kt)("p",null,"Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking. However, you should consider whether each piece of your Redux code needs its own dedicated tests. In the majority of scenarios, the end-user does not know, and does not care whether Redux is used within the application at all. As such, the Redux code can be treated as an implementation detail of the app, without requiring explicit tests for the Redux code in many circumstances."),(0,i.kt)("p",null,"The general advice for testing an app using Redux is as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use integration tests for everything working together. I.e. for a React app using Redux, render a ",(0,i.kt)("inlineCode",{parentName:"li"},"<Provider>")," with a real store instance wrapping the component/s being tested. Interactions with the page being tested should use real Redux logic, with API calls mocked out so app code doesn't have to change, and assert that the UI is updated appropriately."),(0,i.kt)("li",{parentName:"ul"},"If needed, use basic unit tests for pure functions such as particularly complex reducers or selectors. However, in many cases, these are just implementation details that are covered by integration tests instead.")),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For background on why we recommend integration-style tests, see:"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"Kent C Dodds: ",(0,i.kt)("a",{parentName:"li",href:"https://kentcdodds.com/blog/testing-implementation-details"},"Testing Implementation Details"),": thoughts on why he recommends avoiding testing implementation details."),(0,i.kt)("li",{parentName:"ul"},"Mark Erikson: ",(0,i.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2021/06/the-evolution-of-redux-testing-approaches/"},"Blogged Answers: The Evolution of Redux Testing Approaches"),": thoughts on how Redux testing has evolved from 'isolation' to 'integration' over time.")))),(0,i.kt)("h2",{id:"setting-up"},"Setting Up"),(0,i.kt)("p",null,"Redux can be tested with any test runner, however in the examples below we will be using ",(0,i.kt)("a",{parentName:"p",href:"https://facebook.github.io/jest/"},"Jest"),", a popular testing framework.\nNote that it runs in a Node environment, so you won't have access to the real DOM.\nJest can instead use ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jsdom/jsdom"},"jsdom")," to emulate portions of the browser in a test environment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"npm install --save-dev jest\n")),(0,i.kt)("p",null,"To use it together with ",(0,i.kt)("a",{parentName:"p",href:"https://babeljs.io"},"Babel"),", you will need to install ",(0,i.kt)("inlineCode",{parentName:"p"},"babel-jest"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"npm install --save-dev babel-jest\n")),(0,i.kt)("p",null,"and configure it to use ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/babel/babel/tree/master/packages/babel-preset-env"},"babel-preset-env")," features in ",(0,i.kt)("inlineCode",{parentName:"p"},".babelrc"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "presets": ["@babel/preset-env"]\n}\n')),(0,i.kt)("p",null,"Then, add this to ",(0,i.kt)("inlineCode",{parentName:"p"},"scripts")," in your ",(0,i.kt)("inlineCode",{parentName:"p"},"package.json"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'{\n  ...\n  "scripts": {\n    ...\n    "test": "jest",\n    "test:watch": "npm test -- --watch"\n  },\n  ...\n}\n')),(0,i.kt)("p",null,"and run ",(0,i.kt)("inlineCode",{parentName:"p"},"npm test")," to run it once, or ",(0,i.kt)("inlineCode",{parentName:"p"},"npm run test:watch")," to test on every file change."),(0,i.kt)("h2",{id:"action-creators--thunks"},"Action Creators & Thunks"),(0,i.kt)("p",null,"In Redux, action creators are functions which return plain objects. Our recommendation is not to write action creators manually, but instead have them generated automatically by ",(0,i.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createSlice#return-value"},(0,i.kt)("inlineCode",{parentName:"a"},"createSlice")),", or created via ",(0,i.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createAction"},(0,i.kt)("inlineCode",{parentName:"a"},"createAction"))," from ",(0,i.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/introduction/getting-started"},(0,i.kt)("inlineCode",{parentName:"a"},"@reduxjs/toolkit")),". As such, you should not feel the need to test action creators by themselves (the Redux Toolkit maintainers have already done that for you!)."),(0,i.kt)("p",null,"The return value of action creators is considered an implementation detail within your application, and when following an integration testing style, do not need explicit tests."),(0,i.kt)("p",null,"Similarly for thunks using ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-thunk"},"Redux Thunk"),", our recommendation is not to write them manually, but instead use ",(0,i.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createAsyncThunk"},(0,i.kt)("inlineCode",{parentName:"a"},"createAsyncThunk"))," from ",(0,i.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/introduction/getting-started"},(0,i.kt)("inlineCode",{parentName:"a"},"@reduxjs/toolkit")),". The thunk handles dispatching the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"pending"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"fulfilled")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"rejected")," action types for you based on the lifecycle of the thunk."),(0,i.kt)("p",null,"We consider thunk behavior to be an implementation detail of the application, and recommend that it be covered by testing the group of components (or whole app) using it, rather than testing the thunk in isolation."),(0,i.kt)("p",null,"Our recommendation is to mock async requests at the ",(0,i.kt)("inlineCode",{parentName:"p"},"fetch/xhr")," level using tools like ",(0,i.kt)("a",{parentName:"p",href:"https://mswjs.io/"},(0,i.kt)("inlineCode",{parentName:"a"},"msw")),", ",(0,i.kt)("a",{parentName:"p",href:"https://miragejs.com/"},(0,i.kt)("inlineCode",{parentName:"a"},"miragejs")),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jefflau/jest-fetch-mock#readme"},(0,i.kt)("inlineCode",{parentName:"a"},"jest-fetch-mock")),", ",(0,i.kt)("a",{parentName:"p",href:"https://www.wheresrhys.co.uk/fetch-mock/"},(0,i.kt)("inlineCode",{parentName:"a"},"fetch-mock")),', or similar. By mocking requests at this level, none of the thunk logic has to change in a test - the thunk still tries to make a "real" async request, it just gets intercepted. See the ',(0,i.kt)("a",{parentName:"p",href:"#example-1"},"components example")," for an example of testing a component which internally includes the behavior of a thunk."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"If you prefer, or are otherwise required to write unit tests for your action creators or thunks, refer to the tests that Redux Toolkit uses for ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-toolkit/blob/635d6d5e513e13dd59cd717f600d501b30ca2381/src/tests/createAction.test.ts"},(0,i.kt)("inlineCode",{parentName:"a"},"createAction"))," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-toolkit/blob/635d6d5e513e13dd59cd717f600d501b30ca2381/src/tests/createAsyncThunk.test.ts"},(0,i.kt)("inlineCode",{parentName:"a"},"createAsyncThunk")),"."))),(0,i.kt)("h2",{id:"reducers"},"Reducers"),(0,i.kt)("p",null,"Reducers are pure functions that return the new state after applying the action to the previous state. In the majority of cases, the reducer is an implementation detail that does not need explicit tests. However, if your reducer contains particularly complex logic that you would like the confidence of having unit tests for, reducers can be easily tested."),(0,i.kt)("p",null,"Because reducers are pure functions, testing them should be straightforward. Call the reducer with a specific input ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"action"),", and assert that the result state matches expectations."),(0,i.kt)("h4",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = [\n  {\n    text: 'Use Redux',\n    completed: false,\n    id: 0\n  }\n]\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    todoAdded(state, action: PayloadAction<string>) {\n      state.push({\n        id: state.reduce((maxId, todo) => Math.max(todo.id, maxId), -1) + 1,\n        completed: false,\n        text: action.payload\n      })\n    }\n  }\n})\n\nexport const { todoAdded } = todosSlice.actions\n\nexport default todosSlice.reducer\n")),(0,i.kt)("p",null,"can be tested like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import reducer, { todoAdded } from './todosSlice'\n\ntest('should return the initial state', () => {\n  expect(reducer(undefined, {})).toEqual([\n    {\n      text: 'Use Redux',\n      completed: false,\n      id: 0\n    }\n  ])\n})\n\ntest('should handle a todo being added to an empty list', () => {\n  const previousState = []\n  expect(reducer(previousState, todoAdded('Run the tests'))).toEqual([\n    {\n      text: 'Run the tests',\n      completed: false,\n      id: 0\n    }\n  ])\n})\n\ntest('should handle a todo being added to an existing list', () => {\n  const previousState = [\n    {\n      text: 'Run the tests',\n      completed: true,\n      id: 0\n    }\n  ]\n  expect(reducer(previousState, todoAdded('Use Redux'))).toEqual([\n    {\n      text: 'Run the tests',\n      completed: true,\n      id: 0\n    },\n    {\n      text: 'Use Redux',\n      completed: false,\n      id: 1\n    }\n  ])\n})\n")),(0,i.kt)("h2",{id:"components"},"Components"),(0,i.kt)("p",null,"Our recommendation for testing components that include Redux code is via integration tests that include everything working together, with assertions aimed at verifying that the app behaves the way you expect when the user interacts with it in a given manner."),(0,i.kt)("p",null,"First, we will install ",(0,i.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/react-testing-library/intro"},"React Testing Library"),". React Testing Library is a simple and complete React DOM testing utility that encourages good testing practices. It uses react-dom's ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," function and ",(0,i.kt)("inlineCode",{parentName:"p"},"act")," from react-dom/tests-utils."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"npm install --save-dev @testing-library/react\n")),(0,i.kt)("p",null,"If you are using jest, we also recommend installing ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/testing-library/jest-dom"},"jest-dom")," as it provides a set of custom jest matchers that you can use to extend jest. These will make your tests more declarative, clear to read and to maintain. jest-dom is being used in the examples below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"npm install --save-dev @testing-library/jest-dom\n")),(0,i.kt)("h4",{id:"example-1"},"Example"),(0,i.kt)("p",null,"Consider the following ",(0,i.kt)("inlineCode",{parentName:"p"},"userSlice")," slice and ",(0,i.kt)("inlineCode",{parentName:"p"},"App")," component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'\nimport { userAPI } from './userAPI'\n\nexport const fetchUser = createAsyncThunk('user/fetchUser', async () => {\n  const response = await userAPI.fetchUser()\n  return response.data\n})\n\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    name: 'No user',\n    status: 'idle'\n  },\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchUser.pending, (state, action) => {\n      state.status = 'loading'\n    })\n    builder.addCase(fetchUser.fulfilled, (state, action) => {\n      state.status = 'complete'\n      state.name = action.payload\n    })\n  }\n})\n\nexport const selectUser = state => state.user.name\nexport const selectUserFetchStatus = state => state.user.status\n\nexport default userSlice.reducer\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { fetchUser, selectUser, selectUserFetchStatus } from './userSlice'\n\nexport default function App() {\n  const dispatch = useDispatch()\n  const user = useSelector(selectUser)\n  const userFetchStatus = useSelector(selectUserFetchStatus)\n\n  return (\n    <div>\n      {/* Display the current user name */}\n      <div>{user}</div>\n      {/* On button click, dispatch a thunk action to fetch a user */}\n      <button onClick={() => dispatch(fetchUser())}>Fetch user</button>\n      {/* At any point if we're fetching a user, display that on the UI */}\n      {userFetchStatus === 'loading' && <div>Fetching user...</div>}\n    </div>\n  )\n}\n")),(0,i.kt)("p",null,"This app involves thunks, reducers and selectors. All of these can be tested by writing an integration test with the following in mind:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Upon first loading the app, there should be no user yet - we should see 'No user' on the screen."),(0,i.kt)("li",{parentName:"ul"},"After clicking the button that says 'Fetch user', we expect it to start fetching the user. We should see 'Fetching user...' displayed on the screen."),(0,i.kt)("li",{parentName:"ul"},"After some time, the user should be received. We should no longer see 'Fetching user...', but instead should see the expected user's name based on the response from our API.")),(0,i.kt)("p",null,"Writing our tests to focus on the above as a whole, we can avoid mocking as much of the app as possible. We will also have confidence that the critical behavior of our app does what we expect it to when interacted with in the way we expect the user to use the app."),(0,i.kt)("p",null,"To test the component, we ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," it into the DOM, and assert that the app responds to interactions in the way we expect the user to use the app. We can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapper")," option in the ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," function and export our own ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," function as explained in React Testing Library's ",(0,i.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/react-testing-library/setup"},"setup docs"),"."),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," function can look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"// test-utils.jsx\nimport React from 'react'\nimport { render as rtlRender } from '@testing-library/react'\nimport { configureStore } from '@reduxjs/toolkit'\nimport { Provider } from 'react-redux'\n// Import your own reducer\nimport userReducer from '../userSlice'\n\nfunction render(\n  ui,\n  {\n    preloadedState,\n    store = configureStore({ reducer: { user: userReducer }, preloadedState }),\n    ...renderOptions\n  } = {}\n) {\n  function Wrapper({ children }) {\n    return <Provider store={store}>{children}</Provider>\n  }\n  return rtlRender(ui, { wrapper: Wrapper, ...renderOptions })\n}\n\n// re-export everything\nexport * from '@testing-library/react'\n// override render method\nexport { render }\n")),(0,i.kt)("p",null,"And our test can use our exported ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," function to test the criteria of our integration test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react'\nimport { rest } from 'msw'\nimport { setupServer } from 'msw/node'\n// We're using our own custom render function and not RTL's render.\n// Our custom utils also re-export everything from RTL\n// so we can import fireEvent and screen here as well\nimport { render, fireEvent, screen } from '../../test-utils'\nimport App from '../../containers/App'\n\n// We use msw to intercept the network request during the test,\n// and return the response 'John Smith' after 150ms\n// when receiving a get request to the `/api/user` endpoint\nexport const handlers = [\n  rest.get('/api/user', (req, res, ctx) => {\n    return res(ctx.json('John Smith'), ctx.delay(150))\n  })\n]\n\nconst server = setupServer(...handlers)\n\n// Enable API mocking before tests.\nbeforeAll(() => server.listen())\n\n// Reset any runtime request handlers we may add during the tests.\nafterEach(() => server.resetHandlers())\n\n// Disable API mocking after the tests are done.\nafterAll(() => server.close())\n\ntest('fetches & receives a user after clicking the fetch user button', async () => {\n  render(<App />)\n\n  // should show no user initially, and not be fetching a user\n  expect(screen.getByText(/no user/i)).toBeInTheDocument()\n  expect(screen.queryByText(/Fetching user\\.\\.\\./i)).not.toBeInTheDocument()\n\n  // after clicking the 'Fetch user' button, it should now show that it is fetching the user\n  fireEvent.click(screen.getByRole('button', { name: /Fetch user/i }))\n  expect(screen.getByText(/no user/i)).toBeInTheDocument()\n\n  // after some time, the user should be received\n  expect(await screen.findByText(/John Smith/i)).toBeInTheDocument()\n  expect(screen.queryByText(/no user/i)).not.toBeInTheDocument()\n  expect(screen.queryByText(/Fetching user\\.\\.\\./i)).not.toBeInTheDocument()\n})\n")),(0,i.kt)("p",null,"In this test, we have completely avoided testing any Redux code directly, treating it as an implementation detail. As a result, we are free to re-factor the ",(0,i.kt)("em",{parentName:"p"},"implementation"),", while our tests will continue to pass and avoid false negatives (tests that fail despite the app still behaving how we want it to). We might change our state structure, convert our slice to use ",(0,i.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/rtk-query/overview"},"RTK-Query"),", or remove Redux entirely, and our tests will still pass. We have a strong degree of confidence that if we change some code and our tests report a failure, then our app really ",(0,i.kt)("em",{parentName:"p"},"is")," broken."),(0,i.kt)("h2",{id:"middleware"},"Middleware"),(0,i.kt)("p",null,"Middleware functions wrap behavior of ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch")," calls in Redux, so to test this modified behavior we need to mock the behavior of the ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch")," call."),(0,i.kt)("h4",{id:"example-2"},"Example"),(0,i.kt)("p",null,"First, we'll need a middleware function. This is similar to the real ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-thunk/blob/master/src/index.ts"},"redux-thunk"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const thunk =\n  ({ dispatch, getState }) =>\n  next =>\n  action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState)\n    }\n\n    return next(action)\n  }\n")),(0,i.kt)("p",null,"We need to create fake ",(0,i.kt)("inlineCode",{parentName:"p"},"getState"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," functions. We use ",(0,i.kt)("inlineCode",{parentName:"p"},"jest.fn()")," to create stubs, but with other test frameworks you would likely use ",(0,i.kt)("a",{parentName:"p",href:"https://sinonjs.org/"},"Sinon"),"."),(0,i.kt)("p",null,"The invoke function runs our middleware in the same way Redux does."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const create = () => {\n  const store = {\n    getState: jest.fn(() => ({})),\n    dispatch: jest.fn()\n  }\n  const next = jest.fn()\n\n  const invoke = action => thunk(store)(next)(action)\n\n  return { store, next, invoke }\n}\n")),(0,i.kt)("p",null,"We test that our middleware is calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"getState"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," functions at the right time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"test('passes through non-function action', () => {\n  const { next, invoke } = create()\n  const action = { type: 'TEST' }\n  invoke(action)\n  expect(next).toHaveBeenCalledWith(action)\n})\n\ntest('calls the function', () => {\n  const { invoke } = create()\n  const fn = jest.fn()\n  invoke(fn)\n  expect(fn).toHaveBeenCalled()\n})\n\ntest('passes dispatch and getState', () => {\n  const { store, invoke } = create()\n  invoke((dispatch, getState) => {\n    dispatch('TEST DISPATCH')\n    getState()\n  })\n  expect(store.dispatch).toHaveBeenCalledWith('TEST DISPATCH')\n  expect(store.getState).toHaveBeenCalled()\n})\n")),(0,i.kt)("p",null,"In some cases, you will need to modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"create")," function to use different mock implementations of ",(0,i.kt)("inlineCode",{parentName:"p"},"getState")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"next"),"."),(0,i.kt)("h2",{id:"further-information"},"Further Information"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/react-testing-library/intro"},"React Testing Library"),': React Testing Library is a very light-weight solution for testing React components. It provides light utility functions on top of react-dom and react-dom/test-utils, in a way that encourages better testing practices. Its primary guiding principle is: "The more your tests resemble the way your software is used, the more confidence they can give you."')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/test-utils.html"},"React Test Utils"),": ReactTestUtils makes it easy to test React components in the testing framework of your choice. React Testing Library uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"act")," function exported by React Test Utils.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://blog.isquaredsoftware.com/2021/06/the-evolution-of-redux-testing-approaches/"},"Blogged Answers: The Evolution of Redux Testing Approaches"),": Mark Erikson's thoughts on how Redux testing has evolved from 'isolation' to 'integration'.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://kentcdodds.com/blog/testing-implementation-details"},"Testing Implementation Details"),": Blog post by Kent C. Dodds on why he recommends to avoid testing implementation details."))))}m.isMDXComponent=!0}}]);