"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5286],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return p}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),d=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(c.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=d(n),p=o,h=u["".concat(c,".").concat(p)]||u[p]||l[p]||r;return n?a.createElement(h,s(s({ref:t},m),{},{components:n})):a.createElement(h,s({ref:t},m))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var d=2;d<r;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9301:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return i},metadata:function(){return d},toc:function(){return l}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),s=["components"],i={id:"updating-normalized-data",title:"Updating Normalized Data",sidebar_label:"Updating Normalized Data",description:"Structuring Reducers > Updating Normalized Data: Patterns for updating normalized data"},c="Managing Normalized Data",d={unversionedId:"usage/structuring-reducers/updating-normalized-data",id:"usage/structuring-reducers/updating-normalized-data",title:"Updating Normalized Data",description:"Structuring Reducers > Updating Normalized Data: Patterns for updating normalized data",source:"@site/../docs/usage/structuring-reducers/UpdatingNormalizedData.md",sourceDirName:"usage/structuring-reducers",slug:"/usage/structuring-reducers/updating-normalized-data",permalink:"/usage/structuring-reducers/updating-normalized-data",draft:!1,tags:[],version:"current",frontMatter:{id:"updating-normalized-data",title:"Updating Normalized Data",sidebar_label:"Updating Normalized Data",description:"Structuring Reducers > Updating Normalized Data: Patterns for updating normalized data"}},m={},l=[{value:"Standard Approaches",id:"standard-approaches",level:2},{value:"Simple Merging",id:"simple-merging",level:3},{value:"Slice Reducer Composition",id:"slice-reducer-composition",level:3},{value:"Other Approaches",id:"other-approaches",level:2},{value:"Task-Based Updates",id:"task-based-updates",level:3},{value:"Redux-ORM",id:"redux-orm",level:3}],u={toc:l};function p(e){var t=e.components,n=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"managing-normalized-data"},"Managing Normalized Data"),(0,r.kt)("p",null,"As mentioned in ",(0,r.kt)("a",{parentName:"p",href:"/usage/structuring-reducers/normalizing-state-shape"},"Normalizing State Shape"),", the Normalizr library is frequently used to transform nested response data into a normalized shape suitable for integration into the store. However, that doesn't address the issue of executing further updates to that normalized data as it's being used elsewhere in the application. There are a variety of different approaches that you can use, based on your own preference. We'll use the example of handling mutations for Comments on a Post."),(0,r.kt)("h2",{id:"standard-approaches"},"Standard Approaches"),(0,r.kt)("h3",{id:"simple-merging"},"Simple Merging"),(0,r.kt)("p",null,"One approach is to merge the contents of the action into the existing state. In this case, we can use deep recursive merge, not just a shallow copy, to allow for actions with partial items to update stored items. The Lodash ",(0,r.kt)("inlineCode",{parentName:"p"},"merge")," function can handle this for us:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import merge from 'lodash/merge'\n\nfunction commentsById(state = {}, action) {\n  switch (action.type) {\n    default: {\n      if (action.entities && action.entities.comments) {\n        return merge({}, state, action.entities.comments.byId)\n      }\n      return state\n    }\n  }\n}\n")),(0,r.kt)("p",null,"This requires the least amount of work on the reducer side, but does require that the action creator potentially do a fair amount of work to organize the data into the correct shape before the action is dispatched. It also doesn't handle trying to delete an item."),(0,r.kt)("h3",{id:"slice-reducer-composition"},"Slice Reducer Composition"),(0,r.kt)("p",null,"If we have a nested tree of slice reducers, each slice reducer will need to know how to respond to this action appropriately. We will need to include all the relevant data in the action. We need to update the correct Post object with the comment's ID, create a new Comment object using that ID as a key, and include the Comment's ID in the list of all Comment IDs. Here's how the pieces for this might fit together:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// actions.js\nfunction addComment(postId, commentText) {\n  // Generate a unique ID for this comment\n  const commentId = generateId('comment')\n\n  return {\n    type: 'ADD_COMMENT',\n    payload: {\n      postId,\n      commentId,\n      commentText\n    }\n  }\n}\n\n// reducers/posts.js\nfunction addComment(state, action) {\n  const { payload } = action\n  const { postId, commentId } = payload\n\n  // Look up the correct post, to simplify the rest of the code\n  const post = state[postId]\n\n  return {\n    ...state,\n    // Update our Post object with a new \"comments\" array\n    [postId]: {\n      ...post,\n      comments: post.comments.concat(commentId)\n    }\n  }\n}\n\nfunction postsById(state = {}, action) {\n  switch (action.type) {\n    case 'ADD_COMMENT':\n      return addComment(state, action)\n    default:\n      return state\n  }\n}\n\nfunction allPosts(state = [], action) {\n  // omitted - no work to be done for this example\n}\n\nconst postsReducer = combineReducers({\n  byId: postsById,\n  allIds: allPosts\n})\n\n// reducers/comments.js\nfunction addCommentEntry(state, action) {\n  const { payload } = action\n  const { commentId, commentText } = payload\n\n  // Create our new Comment object\n  const comment = { id: commentId, text: commentText }\n\n  // Insert the new Comment object into the updated lookup table\n  return {\n    ...state,\n    [commentId]: comment\n  }\n}\n\nfunction commentsById(state = {}, action) {\n  switch (action.type) {\n    case 'ADD_COMMENT':\n      return addCommentEntry(state, action)\n    default:\n      return state\n  }\n}\n\nfunction addCommentId(state, action) {\n  const { payload } = action\n  const { commentId } = payload\n  // Just append the new Comment's ID to the list of all IDs\n  return state.concat(commentId)\n}\n\nfunction allComments(state = [], action) {\n  switch (action.type) {\n    case 'ADD_COMMENT':\n      return addCommentId(state, action)\n    default:\n      return state\n  }\n}\n\nconst commentsReducer = combineReducers({\n  byId: commentsById,\n  allIds: allComments\n})\n")),(0,r.kt)("p",null,"The example is a bit long, because it's showing how all the different slice reducers and case reducers fit together. Note the delegation involved here. The ",(0,r.kt)("inlineCode",{parentName:"p"},"postsById")," slice reducer delegates the work for this case to ",(0,r.kt)("inlineCode",{parentName:"p"},"addComment"),", which inserts the new Comment's ID into the correct Post item. Meanwhile, both the ",(0,r.kt)("inlineCode",{parentName:"p"},"commentsById")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"allComments")," slice reducers have their own case reducers, which update the Comments lookup table and list of all Comment IDs appropriately."),(0,r.kt)("h2",{id:"other-approaches"},"Other Approaches"),(0,r.kt)("h3",{id:"task-based-updates"},"Task-Based Updates"),(0,r.kt)("p",null,"Since reducers are just functions, there's an infinite number of ways to split up this logic. While using slice reducers is the most common, it's also possible to organize behavior in a more task-oriented structure. Because this will often involve more nested updates, you may want to use an immutable update utility library like ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/debitoor/dot-prop-immutable"},"dot-prop-immutable")," or ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mariocasciaro/object-path-immutable"},"object-path-immutable")," to simplify the update statements. Here's an example of what that might look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import posts from "./postsReducer";\nimport comments from "./commentsReducer";\nimport dotProp from "dot-prop-immutable";\nimport {combineReducers} from "redux";\nimport reduceReducers from "reduce-reducers";\n\nconst combinedReducer = combineReducers({\n    posts,\n    comments\n});\n\n\nfunction addComment(state, action) {\n    const {payload} = action;\n    const {postId, commentId, commentText} = payload;\n\n    // State here is the entire combined state\n    const updatedWithPostState = dotProp.set(\n        state,\n        `posts.byId.${postId}.comments`,\n        comments => comments.concat(commentId)\n    );\n\n    const updatedWithCommentsTable = dotProp.set(\n        updatedWithPostState,\n        `comments.byId.${commentId}`,\n        {id : commentId, text : commentText}\n    );\n\n    const updatedWithCommentsList = dotProp.set(\n        updatedWithCommentsTable,\n        `comments.allIds`,\n        allIds => allIds.concat(commentId);\n    );\n\n    return updatedWithCommentsList;\n}\n\nconst featureReducers = createReducer({}, {\n    ADD_COMMENT : addComment,\n});\n\nconst rootReducer = reduceReducers(\n    combinedReducer,\n    featureReducers\n);\n')),(0,r.kt)("p",null,"This approach makes it very clear what's happening for the ",(0,r.kt)("inlineCode",{parentName:"p"},'"ADD_COMMENTS"')," case, but it does require nested updating logic, and some specific knowledge of the state tree shape. Depending on how you want to compose your reducer logic, this may or may not be desired."),(0,r.kt)("h3",{id:"redux-orm"},"Redux-ORM"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/redux-orm/redux-orm"},"Redux-ORM"),' library provides a very useful abstraction layer for managing normalized data in a Redux store. It allows you to declare Model classes and define relations between them. It can then generate the empty "tables" for your data types, act as a specialized selector tool for looking up the data, and perform immutable updates on that data.'),(0,r.kt)("p",null,"There's a couple ways Redux-ORM can be used to perform updates. First, the Redux-ORM docs suggest defining reducer functions on each Model subclass, then including the auto-generated combined reducer function into your store:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// models.js\nimport { Model, fk, attr, ORM } from 'redux-orm'\n\nexport class Post extends Model {\n  static get fields() {\n    return {\n      id: attr(),\n      name: attr()\n    }\n  }\n\n  static reducer(action, Post, session) {\n    switch (action.type) {\n      case 'CREATE_POST': {\n        Post.create(action.payload)\n        break\n      }\n    }\n  }\n}\nPost.modelName = 'Post'\n\nexport class Comment extends Model {\n  static get fields() {\n    return {\n      id: attr(),\n      text: attr(),\n      // Define a foreign key relation - one Post can have many Comments\n      postId: fk({\n        to: 'Post', // must be the same as Post.modelName\n        as: 'post', // name for accessor (comment.post)\n        relatedName: 'comments' // name for backward accessor (post.comments)\n      })\n    }\n  }\n\n  static reducer(action, Comment, session) {\n    switch (action.type) {\n      case 'ADD_COMMENT': {\n        Comment.create(action.payload)\n        break\n      }\n    }\n  }\n}\nComment.modelName = 'Comment'\n\n// Create an ORM instance and hook up the Post and Comment models\nexport const orm = new ORM()\norm.register(Post, Comment)\n\n// main.js\nimport { createStore, combineReducers } from 'redux'\nimport { createReducer } from 'redux-orm'\nimport { orm } from './models'\n\nconst rootReducer = combineReducers({\n  // Insert the auto-generated Redux-ORM reducer.  This will\n  // initialize our model \"tables\", and hook up the reducer\n  // logic we defined on each Model subclass\n  entities: createReducer(orm)\n})\n\n// Dispatch an action to create a Post instance\nstore.dispatch({\n  type: 'CREATE_POST',\n  payload: {\n    id: 1,\n    name: 'Test Post Please Ignore'\n  }\n})\n\n// Dispatch an action to create a Comment instance as a child of that Post\nstore.dispatch({\n  type: 'ADD_COMMENT',\n  payload: {\n    id: 123,\n    text: 'This is a comment',\n    postId: 1\n  }\n})\n")),(0,r.kt)("p",null,"The Redux-ORM library maintains relationships between models for you. Updates are by default applied immutably, simplifying the update process."),(0,r.kt)("p",null,"Another variation on this is to use Redux-ORM as an abstraction layer within a single case reducer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { orm } from './models'\n\n// Assume this case reducer is being used in our \"entities\" slice reducer,\n// and we do not have reducers defined on our Redux-ORM Model subclasses\nfunction addComment(entitiesState, action) {\n  // Start an immutable session\n  const session = orm.session(entitiesState)\n\n  session.Comment.create(action.payload)\n\n  // The internal state reference has now changed\n  return session.state\n}\n")),(0,r.kt)("p",null,"By using the session interface you can now use relationship accessors to directly access referenced models:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const session = orm.session(store.getState().entities)\nconst comment = session.Comment.first() // Comment instance\nconst { post } = comment // Post instance\npost.comments.filter(c => c.text === 'This is a comment').count() // 1\n")),(0,r.kt)("p",null,'Overall, Redux-ORM provides a very useful set of abstractions for defining relations between data types, creating the "tables" in our state, retrieving and denormalizing relational data, and applying immutable updates to relational data.'))}p.isMDXComponent=!0}}]);