"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5399],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return m}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,p=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),d=u(n),m=o,h=d["".concat(p,".").concat(m)]||d[m]||c[m]||s;return n?r.createElement(h,a(a({ref:t},l),{},{components:n})):r.createElement(h,a({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,a=new Array(s);a[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var u=2;u<s;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5307:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return c}});var r=n(7462),o=n(3366),s=(n(7294),n(3905)),a=["components"],i={id:"writing-tests",title:"Writing Tests",description:"Usage > Writing Tests: recommended practices and setup for testing Redux apps"},p="Writing Tests",u={unversionedId:"usage/writing-tests",id:"usage/writing-tests",title:"Writing Tests",description:"Usage > Writing Tests: recommended practices and setup for testing Redux apps",source:"@site/../docs/usage/WritingTests.mdx",sourceDirName:"usage",slug:"/usage/writing-tests",permalink:"/usage/writing-tests",draft:!1,tags:[],version:"current",frontMatter:{id:"writing-tests",title:"Writing Tests",description:"Usage > Writing Tests: recommended practices and setup for testing Redux apps"},sidebar:"docs",previous:{title:"Usage With TypeScript",permalink:"/usage/usage-with-typescript"},next:{title:"Troubleshooting",permalink:"/usage/troubleshooting"}},l={},c=[{value:"Guiding Principles",id:"guiding-principles",level:2},{value:"Setting Up a Test Environment",id:"setting-up-a-test-environment",level:2},{value:"Test Runners",id:"test-runners",level:3},{value:"UI and Network Testing Tools",id:"ui-and-network-testing-tools",level:3},{value:"Integration Testing Connected Components and Redux Logic",id:"integration-testing-connected-components-and-redux-logic",level:2},{value:"Example App Code",id:"example-app-code",level:3},{value:"Setting Up a Reusable Test Render Function",id:"setting-up-a-reusable-test-render-function",level:3},{value:"Writing Integration Tests With Components",id:"writing-integration-tests-with-components",level:3},{value:"Preparing Initial Test State",id:"preparing-initial-test-state",level:3},{value:"Unit Testing Individual Functions",id:"unit-testing-individual-functions",level:2},{value:"Reducers",id:"reducers",level:3},{value:"Example",id:"example",level:4},{value:"Selectors",id:"selectors",level:3},{value:"Action Creators &amp; Thunks",id:"action-creators--thunks",level:3},{value:"Middleware",id:"middleware",level:3},{value:"Example",id:"example-1",level:4},{value:"Further Information",id:"further-information",level:2}],d={toc:c};function m(e){var t=e.components,n=(0,o.Z)(e,a);return(0,s.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"writing-tests"},"Writing Tests"),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"What You'll Learn")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("ul",{parentName:"div"},(0,s.kt)("li",{parentName:"ul"},"Recommended practices for testing apps using Redux"),(0,s.kt)("li",{parentName:"ul"},"Examples of test configuration and setup")))),(0,s.kt)("h2",{id:"guiding-principles"},"Guiding Principles"),(0,s.kt)("p",null,"The guiding principles for testing Redux logic closely follow that of React Testing Library:"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("a",{parentName:"p",href:"https://twitter.com/kentcdodds/status/977018512689455106"},"The more your tests resemble the way your software is used, the more confidence they can give you.")," - Kent C. Dodds")),(0,s.kt)("p",null,"Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking. However, you should consider whether each piece of your Redux code needs its own dedicated tests. ",(0,s.kt)("strong",{parentName:"p"},"In the majority of scenarios, the end-user does not know, and does not care whether Redux is used within the application at all"),". As such, the Redux code can be treated as an implementation detail of the app, without requiring explicit tests for the Redux code in many circumstances."),(0,s.kt)("p",null,"Our general advice for testing an app using Redux is:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Prefer writing integration tests with everything working together"),". For a React app using Redux, render a ",(0,s.kt)("inlineCode",{parentName:"li"},"<Provider>")," with a real store instance wrapping the components being tested. Interactions with the page being tested should use real Redux logic, with API calls mocked out so app code doesn't have to change, and assert that the UI is updated appropriately."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"If")," needed, use basic unit tests for pure functions such as particularly complex reducers or selectors. However, in many cases, these are just implementation details that are covered by integration tests instead."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Do ",(0,s.kt)("em",{parentName:"strong"},"not")," try to mock selector functions or the React-Redux hooks!")," Mocking imports from libraries is fragile, and doesn't give you confidence that your actual app code is working.")),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"For background on why we recommend integration-style tests, see:"),(0,s.kt)("ul",{parentName:"div"},(0,s.kt)("li",{parentName:"ul"},"Kent C Dodds: ",(0,s.kt)("a",{parentName:"li",href:"https://kentcdodds.com/blog/testing-implementation-details"},"Testing Implementation Details"),": thoughts on why he recommends avoiding testing implementation details."),(0,s.kt)("li",{parentName:"ul"},"Mark Erikson: ",(0,s.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2021/06/the-evolution-of-redux-testing-approaches/"},"Blogged Answers: The Evolution of Redux Testing Approaches"),": thoughts on how Redux testing has evolved from 'isolation' to 'integration' over time.")))),(0,s.kt)("h2",{id:"setting-up-a-test-environment"},"Setting Up a Test Environment"),(0,s.kt)("h3",{id:"test-runners"},"Test Runners"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Redux can be tested with any test runner"),", since it's just plain JavaScript. One common option is ",(0,s.kt)("a",{parentName:"p",href:"https://jestjs.io/"},"Jest"),", a widely used test runner that comes with Create-React-App, and is used by the Redux library repos. If you're using ",(0,s.kt)("a",{parentName:"p",href:"https://vitejs.dev/"},"Vite")," to build your project, you may be using ",(0,s.kt)("a",{parentName:"p",href:"https://vitest.dev/"},"Vitest")," as your test runner."),(0,s.kt)("p",null,"Typically, your test runner needs to be configured to compile JavaScript/TypeScript syntax. If you're going to be testing UI components, you will likely need to configure the test runner to use ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/jsdom/jsdom"},"JSDOM")," to provide a mock DOM environment."),(0,s.kt)("p",null,"The examples in this page will assume you're using Jest, but the same patterns apply no matter what test runner you're using."),(0,s.kt)("p",null,"See these resources for typical test runner configuration instructions:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Jest"),":",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://jestjs.io/docs/getting-started"},"Jest: Getting Started")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://jestjs.io/docs/configuration#testenvironment-string"},"Jest: Configuration - Test Environment")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Vitest"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://vitest.dev/guide/"},"Vitest: Getting Started")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://vitest.dev/config/#environment"},"Vitest: Configuration - Test Environment"))))),(0,s.kt)("h3",{id:"ui-and-network-testing-tools"},"UI and Network Testing Tools"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"The Redux team recommends using ",(0,s.kt)("a",{parentName:"strong",href:"https://testing-library.com/docs/react-testing-library/intro"},"React Testing Library (RTL)")," to test React components that connect to Redux"),". React Testing Library is a simple and complete React DOM testing utility that encourages good testing practices. It uses ReactDOM's ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," function and ",(0,s.kt)("inlineCode",{parentName:"p"},"act")," from react-dom/tests-utils. (The Testing Library family of tools also includes ",(0,s.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/dom-testing-library/intro"},"adapters for many other popular frameworks as well"),".)"),(0,s.kt)("p",null,"We also ",(0,s.kt)("strong",{parentName:"p"},"recommend using ",(0,s.kt)("a",{parentName:"strong",href:"https://mswjs.io/"},"Mock Server Worker (MSW)")," to mock network requests"),", as this means your application logic does not need to be changed or mocked when writing tests."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"DOM/React Testing Library"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://testing-library.com/docs/dom-testing-library/setup"},"DOM Testing Library: Setup")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://testing-library.com/docs/react-testing-library/setup"},"React Testing Library: Setup")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://testing-library.com/docs/ecosystem-jest-dom"},"Testing Library Jest-DOM Matchers")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Mock Service Worker"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://mswjs.io/docs/getting-started/install"},"MSW: Installation")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://mswjs.io/docs/getting-started/mocks/rest-api"},"MSW: Setting up mock requests")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://mswjs.io/docs/getting-started/integrate/node"},"MSW: Mock server configuration for Node"))))),(0,s.kt)("h2",{id:"integration-testing-connected-components-and-redux-logic"},"Integration Testing Connected Components and Redux Logic"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Our recommendation for testing Redux-connected React components is via integration tests that include everything working together"),", with assertions aimed at verifying that the app behaves the way you expect when the user interacts with it in a given manner."),(0,s.kt)("h3",{id:"example-app-code"},"Example App Code"),(0,s.kt)("p",null,"Consider the following ",(0,s.kt)("inlineCode",{parentName:"p"},"userSlice")," slice, store, and ",(0,s.kt)("inlineCode",{parentName:"p"},"App")," component:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="features/users/usersSlice.ts"',title:'"features/users/usersSlice.ts"'},"// file: app/store.ts noEmit\nimport userReducer from '../features/users/userSlice'\nexport type RootState = {\n  user: ReturnType<typeof userReducer>\n}\n// file: features/users/userAPI.ts noEmit\nexport const userAPI = {\n  fetchUser: async () => ({\n    data: 'john'\n  })\n}\n// file: features/users/userSlice.ts\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit'\nimport { userAPI } from './userAPI'\nimport type { RootState } from '../../app/store'\n\nexport const fetchUser = createAsyncThunk('user/fetchUser', async () => {\n  const response = await userAPI.fetchUser()\n  return response.data\n})\n\ninterface UserState {\n  name: string\n  status: 'idle' | 'loading' | 'complete'\n}\n\nconst initialState: UserState = {\n  name: 'No user',\n  status: 'idle'\n}\n\nconst userSlice = createSlice({\n  name: 'user',\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchUser.pending, (state, action) => {\n      state.status = 'loading'\n    })\n    builder.addCase(fetchUser.fulfilled, (state, action) => {\n      state.status = 'complete'\n      state.name = action.payload\n    })\n  }\n})\n\nexport const selectUser = (state: RootState) => state.user.name\nexport const selectUserFetchStatus = (state: RootState) => state.user.status\n\nexport default userSlice.reducer\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app/store.ts"',title:'"app/store.ts"'},"// file: features/users/userSlice.ts noEmit\nimport { createSlice } from '@reduxjs/toolkit'\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    name: 'No user',\n    status: 'idle'\n  },\n  reducers: {}\n})\nexport default userSlice.reducer\n// file: app/store.ts\nimport {\n  combineReducers,\n  configureStore,\n  PreloadedState\n} from '@reduxjs/toolkit'\nimport userReducer from '../features/users/userSlice'\n// Create the root reducer independently to obtain the RootState type\nconst rootReducer = combineReducers({\n  user: userReducer\n})\nexport function setupStore(preloadedState?: PreloadedState<RootState>) {\n  return configureStore({\n    reducer: rootReducer,\n    preloadedState\n  })\n}\nexport type RootState = ReturnType<typeof rootReducer>\nexport type AppStore = ReturnType<typeof setupStore>\nexport type AppDispatch = AppStore['dispatch']\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app/hooks.ts"',title:'"app/hooks.ts"'},"// file: features/users/userSlice.ts noEmit\nimport { createSlice } from '@reduxjs/toolkit'\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    name: 'No user',\n    status: 'idle'\n  },\n  reducers: {}\n})\nexport default userSlice.reducer\n// file: app/store.ts noEmit\nimport {\n  combineReducers,\n  configureStore,\n  PreloadedState\n} from '@reduxjs/toolkit'\nimport userReducer from '../features/users/userSlice'\nconst rootReducer = combineReducers({\n  user: userReducer\n})\nexport function setupStore(preloadedState?: PreloadedState<RootState>) {\n  return configureStore({\n    reducer: rootReducer,\n    preloadedState\n  })\n}\nexport type RootState = ReturnType<typeof rootReducer>\nexport type AppStore = ReturnType<typeof setupStore>\nexport type AppDispatch = AppStore['dispatch']\n// file: app/hooks.ts\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\nimport type { RootState, AppDispatch } from './store'\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch: () => AppDispatch = useDispatch\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="features/users/UserDisplay.tsx"',title:'"features/users/UserDisplay.tsx"'},"// file: features/users/userAPI.ts noEmit\nexport const userAPI = {\n  fetchUser: async () => ({\n    data: 'john'\n  })\n}\n// file: app/store.ts noEmit\nimport {\n  combineReducers,\n  configureStore,\n  PreloadedState\n} from '@reduxjs/toolkit'\nimport userReducer from '../features/users/userSlice'\nconst rootReducer = combineReducers({\n  user: userReducer\n})\nexport function setupStore(preloadedState?: PreloadedState<RootState>) {\n  return configureStore({\n    reducer: rootReducer,\n    preloadedState\n  })\n}\nexport type RootState = ReturnType<typeof rootReducer>\nexport type AppStore = ReturnType<typeof setupStore>\nexport type AppDispatch = AppStore['dispatch']\n// file: app/hooks.ts noEmit\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\nimport type { RootState, AppDispatch } from './store'\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>()\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\n// file: features/users/userSlice.ts noEmit\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit'\nimport { userAPI } from './userAPI'\nimport type { RootState } from '../../app/store'\nexport const fetchUser = createAsyncThunk('user/fetchUser', async () => {\n  const response = await userAPI.fetchUser()\n  return response.data\n})\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    name: 'No user',\n    status: 'idle'\n  },\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchUser.pending, (state, action) => {\n      state.status = 'loading'\n    })\n    builder.addCase(fetchUser.fulfilled, (state, action) => {\n      state.status = 'complete'\n      state.name = action.payload\n    })\n  }\n})\nexport const selectUser = (state: RootState) => state.user.name\nexport const selectUserFetchStatus = (state: RootState) => state.user.status\nexport default userSlice.reducer\n// file: features/users/UserDisplay.tsx\nimport React from 'react'\nimport { useAppDispatch, useAppSelector } from '../../app/hooks'\nimport { fetchUser, selectUser, selectUserFetchStatus } from './userSlice'\n\nexport default function UserDisplay() {\n  const dispatch = useAppDispatch()\n  const user = useAppSelector(selectUser)\n  const userFetchStatus = useAppSelector(selectUserFetchStatus)\n\n  return (\n    <div>\n      {/* Display the current user name */}\n      <div>{user}</div>\n      {/* On button click, dispatch a thunk action to fetch a user */}\n      <button onClick={() => dispatch(fetchUser())}>Fetch user</button>\n      {/* At any point if we're fetching a user, display that on the UI */}\n      {userFetchStatus === 'loading' && <div>Fetching user...</div>}\n    </div>\n  )\n}\n")),(0,s.kt)("p",null,"This app involves thunks, reducers and selectors. All of these can be tested by writing an integration test with the following in mind:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Upon first loading the app, there should be no user yet - we should see 'No user' on the screen."),(0,s.kt)("li",{parentName:"ul"},"After clicking the button that says 'Fetch user', we expect it to start fetching the user. We should see 'Fetching user...' displayed on the screen."),(0,s.kt)("li",{parentName:"ul"},"After some time, the user should be received. We should no longer see 'Fetching user...', but instead should see the expected user's name based on the response from our API.")),(0,s.kt)("p",null,"Writing our tests to focus on the above as a whole, we can avoid mocking as much of the app as possible. We will also have confidence that the critical behavior of our app does what we expect it to when interacted with in the way we expect the user to use the app."),(0,s.kt)("p",null,"To test the component, we ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," it into the DOM, and assert that the app responds to interactions in the way we expect the user to use the app."),(0,s.kt)("h3",{id:"setting-up-a-reusable-test-render-function"},"Setting Up a Reusable Test Render Function"),(0,s.kt)("p",null,"React Testing Library's ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," function accepts a tree of React elements and renders those components. Just like in a real app, any Redux-connected components will need ",(0,s.kt)("a",{parentName:"p",href:"https://react-redux.js.org/tutorials/quick-start#provide-the-redux-store-to-react"},"a React-Redux ",(0,s.kt)("inlineCode",{parentName:"a"},"<Provider>")," component wrapped around them"),", with a real Redux store set up and provided."),(0,s.kt)("p",null,"Additionally, ",(0,s.kt)("strong",{parentName:"p"},"the test code should create a separate Redux store instance for every test, rather than reusing the same store instance and resetting its state"),". That ensures no values accidentally leak between tests."),(0,s.kt)("p",null,"Instead of copy-pasting the same store creation and ",(0,s.kt)("inlineCode",{parentName:"p"},"Provider")," setup in every test, we can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"wrapper")," option in the ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," function and ",(0,s.kt)("strong",{parentName:"p"},"export our own customized ",(0,s.kt)("inlineCode",{parentName:"strong"},"renderWithProviders")," function that creates a new Redux store and renders a ",(0,s.kt)("inlineCode",{parentName:"strong"},"<Provider>")),", as explained in ",(0,s.kt)("a",{parentName:"p",href:"https://testing-library.com/docs/react-testing-library/setup#custom-render"},"React Testing Library's setup docs"),"."),(0,s.kt)("p",null,"The custom render function should let us:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Create a new Redux store instance every time it's called, with an optional ",(0,s.kt)("inlineCode",{parentName:"li"},"preloadedState")," value that can be used for an initial value"),(0,s.kt)("li",{parentName:"ul"},"Alternately pass in an already-created Redux store instance"),(0,s.kt)("li",{parentName:"ul"},"Pass through additional options to RTL's original ",(0,s.kt)("inlineCode",{parentName:"li"},"render")," function"),(0,s.kt)("li",{parentName:"ul"},"Automatically wrap the component being tested with a ",(0,s.kt)("inlineCode",{parentName:"li"},"<Provider store={store}>")),(0,s.kt)("li",{parentName:"ul"},"Return the store instance in case the test needs to dispatch more actions or check state")),(0,s.kt)("p",null,"A typical custom render function setup could look like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="utils/test-utils.tsx"',title:'"utils/test-utils.tsx"'},"// file: features/users/userSlice.ts noEmit\nimport { createSlice } from '@reduxjs/toolkit'\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    name: 'No user',\n    status: 'idle'\n  },\n  reducers: {}\n})\nexport default userSlice.reducer\n// file: app/store.ts noEmit\nimport {\n  combineReducers,\n  configureStore,\n  PreloadedState\n} from '@reduxjs/toolkit'\nimport userReducer from '../features/users/userSlice'\nconst rootReducer = combineReducers({\n  user: userReducer\n})\nexport function setupStore(preloadedState?: PreloadedState<RootState>) {\n  return configureStore({\n    reducer: rootReducer,\n    preloadedState\n  })\n}\nexport type RootState = ReturnType<typeof rootReducer>\nexport type AppStore = ReturnType<typeof setupStore>\n// file: utils/test-utils.tsx\nimport React, { PropsWithChildren } from 'react'\nimport { render } from '@testing-library/react'\nimport type { RenderOptions } from '@testing-library/react'\nimport { configureStore } from '@reduxjs/toolkit'\nimport type { PreloadedState } from '@reduxjs/toolkit'\nimport { Provider } from 'react-redux'\n\nimport type { AppStore, RootState } from '../app/store'\n// As a basic setup, import your same slice reducers\nimport userReducer from '../features/users/userSlice'\n\n// This type interface extends the default options for render from RTL, as well\n// as allows the user to specify other things such as initialState, store.\ninterface ExtendedRenderOptions extends Omit<RenderOptions, 'queries'> {\n  preloadedState?: PreloadedState<RootState>\n  store?: AppStore\n}\n\nexport function renderWithProviders(\n  ui: React.ReactElement,\n  {\n    preloadedState = {},\n    // Automatically create a store instance if no store was passed in\n    store = configureStore({ reducer: { user: userReducer }, preloadedState }),\n    ...renderOptions\n  }: ExtendedRenderOptions = {}\n) {\n  function Wrapper({ children }: PropsWithChildren<{}>): JSX.Element {\n    return <Provider store={store}>{children}</Provider>\n  }\n\n  // Return an object with the store and all of RTL's query functions\n  return { store, ...render(ui, { wrapper: Wrapper, ...renderOptions }) }\n}\n")),(0,s.kt)("p",null,"In this example, we're directly importing the same slice reducers that the real app uses to create the store. It may be helpful to create a reusable ",(0,s.kt)("inlineCode",{parentName:"p"},"setupStore")," function that does the actual store creation with the right options and configuration, and use that in the custom render function instead."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app/store.ts"',title:'"app/store.ts"'},"// file: features/users/userSlice.ts noEmit\nimport { createSlice } from '@reduxjs/toolkit'\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    name: 'No user',\n    status: 'idle'\n  },\n  reducers: {}\n})\nexport default userSlice.reducer\n// file: app/store.ts\nimport { combineReducers, configureStore } from '@reduxjs/toolkit'\nimport type { PreloadedState } from '@reduxjs/toolkit'\n\nimport userReducer from '../features/users/userSlice'\n\n// Create the root reducer separately so we can extract the RootState type\nconst rootReducer = combineReducers({\n  user: userReducer\n})\n\nexport const setupStore = (preloadedState?: PreloadedState<RootState>) => {\n  return configureStore({\n    reducer: rootReducer,\n    preloadedState\n  })\n}\n\nexport type RootState = ReturnType<typeof rootReducer>\nexport type AppStore = ReturnType<typeof setupStore>\nexport type AppDispatch = AppStore['dispatch']\n")),(0,s.kt)("p",null,"Then, use ",(0,s.kt)("inlineCode",{parentName:"p"},"setupStore")," in the test utils file instead of calling ",(0,s.kt)("inlineCode",{parentName:"p"},"configureStore")," again:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// file: features/users/userSlice.ts noEmit\nimport { createSlice } from '@reduxjs/toolkit'\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    name: 'No user',\n    status: 'idle'\n  },\n  reducers: {}\n})\nexport default userSlice.reducer\n// file: app/store.ts noEmit\nimport { combineReducers, configureStore } from '@reduxjs/toolkit'\nimport type { PreloadedState } from '@reduxjs/toolkit'\n\nimport userReducer from '../features/users/userSlice'\n\nconst rootReducer = combineReducers({\n  user: userReducer\n})\n\nexport const setupStore = (preloadedState?: PreloadedState<RootState>) => {\n  return configureStore({\n    reducer: rootReducer,\n    preloadedState\n  })\n}\n\nexport type RootState = ReturnType<typeof rootReducer>\nexport type AppStore = ReturnType<typeof setupStore>\nexport type AppDispatch = AppStore['dispatch']\n// file: utils/test-utils.tsx\nimport React, { PropsWithChildren } from 'react'\nimport { render } from '@testing-library/react'\nimport type { RenderOptions } from '@testing-library/react'\nimport { configureStore } from '@reduxjs/toolkit'\nimport type { PreloadedState } from '@reduxjs/toolkit'\nimport { Provider } from 'react-redux'\n\nimport { setupStore } from '../app/store'\nimport type { AppStore, RootState } from '../app/store'\n\n// This type interface extends the default options for render from RTL, as well\n// as allows the user to specify other things such as initialState, store.\ninterface ExtendedRenderOptions extends Omit<RenderOptions, 'queries'> {\n  preloadedState?: PreloadedState<RootState>\n  store?: AppStore\n}\n\nexport function renderWithProviders(\n  ui: React.ReactElement,\n  {\n    preloadedState = {},\n    // Automatically create a store instance if no store was passed in\n    store = setupStore(preloadedState),\n    ...renderOptions\n  }: ExtendedRenderOptions = {}\n) {\n  function Wrapper({ children }: PropsWithChildren<{}>): JSX.Element {\n    return <Provider store={store}>{children}</Provider>\n  }\n  return { store, ...render(ui, { wrapper: Wrapper, ...renderOptions }) }\n}\n")),(0,s.kt)("h3",{id:"writing-integration-tests-with-components"},"Writing Integration Tests With Components"),(0,s.kt)("p",null,"The actual test files should use the custom ",(0,s.kt)("inlineCode",{parentName:"p"},"render")," function to actually render our Redux-connected components. If the code that we're testing involves making network requests, we should also configure MSW to mock the expected requests with appropriate test data."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="features/users/tests/UserDisplay.test.tsx"',title:'"features/users/tests/UserDisplay.test.tsx"'},"// file: features/users/userSlice.ts noEmit\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit'\nimport type { RootState } from '../../app/store'\nexport const fetchUser = createAsyncThunk('user/fetchUser', async () => {})\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    name: 'No user',\n    status: 'idle'\n  },\n  reducers: {}\n})\nexport const selectUser = (state: RootState) => state.user.name\nexport const selectUserFetchStatus = (state: RootState) => state.user.status\nexport default userSlice.reducer\n// file: app/store.ts noEmit\nimport { combineReducers, configureStore } from '@reduxjs/toolkit'\nimport type { PreloadedState } from '@reduxjs/toolkit'\n\nimport userReducer from '../features/users/userSlice'\n\nconst rootReducer = combineReducers({\n  user: userReducer\n})\n\nexport const setupStore = (preloadedState?: PreloadedState<RootState>) => {\n  return configureStore({\n    reducer: rootReducer,\n    preloadedState\n  })\n}\n\nexport type RootState = ReturnType<typeof rootReducer>\nexport type AppStore = ReturnType<typeof setupStore>\nexport type AppDispatch = AppStore['dispatch']\n// file: utils/test-utils.tsx noEmit\nimport React, { PropsWithChildren } from 'react'\nimport { render } from '@testing-library/react'\nimport type { RenderOptions } from '@testing-library/react'\nimport { configureStore } from '@reduxjs/toolkit'\nimport type { PreloadedState } from '@reduxjs/toolkit'\nimport { Provider } from 'react-redux'\n\nimport { setupStore } from '../app/store'\nimport type { AppStore, RootState } from '../app/store'\n\ninterface ExtendedRenderOptions extends Omit<RenderOptions, 'queries'> {\n  preloadedState?: PreloadedState<RootState>\n  store?: AppStore\n}\n\nexport function renderWithProviders(\n  ui: React.ReactElement,\n  {\n    preloadedState = {},\n    store = setupStore(preloadedState),\n    ...renderOptions\n  }: ExtendedRenderOptions = {}\n) {\n  function Wrapper({ children }: PropsWithChildren<{}>): JSX.Element {\n    return <Provider store={store}>{children}</Provider>\n  }\n  return { store, ...render(ui, { wrapper: Wrapper, ...renderOptions }) }\n}\n// file: app/hooks.tsx noEmit\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\nimport type { RootState, AppDispatch } from './store'\nexport const useAppDispatch: () => AppDispatch = useDispatch\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\n// file: features/users/UserDisplay.tsx noEmit\nimport React from 'react'\nimport { useAppDispatch, useAppSelector } from '../../app/hooks'\nimport { fetchUser, selectUser, selectUserFetchStatus } from './userSlice'\n\nexport default function UserDisplay() {\n  const dispatch = useAppDispatch()\n  const user = useAppSelector(selectUser)\n  const userFetchStatus = useAppSelector(selectUserFetchStatus)\n\n  return (\n    <div>\n      {/* Display the current user name */}\n      <div>{user}</div>\n      {/* On button click, dispatch a thunk action to fetch a user */}\n      <button onClick={() => dispatch(fetchUser())}>Fetch user</button>\n      {/* At any point if we're fetching a user, display that on the UI */}\n      {userFetchStatus === 'loading' && <div>Fetching user...</div>}\n    </div>\n  )\n}\n// file: features/users/tests/UserDisplay.test.tsx\nimport React from 'react'\nimport { rest } from 'msw'\nimport { setupServer } from 'msw/node'\nimport { fireEvent, screen } from '@testing-library/react'\n// We're using our own custom render function and not RTL's render.\nimport { renderWithProviders } from '../../../utils/test-utils'\nimport UserDisplay from '../UserDisplay'\n\n// We use msw to intercept the network request during the test,\n// and return the response 'John Smith' after 150ms\n// when receiving a get request to the `/api/user` endpoint\nexport const handlers = [\n  rest.get('/api/user', (req, res, ctx) => {\n    return res(ctx.json('John Smith'), ctx.delay(150))\n  })\n]\n\nconst server = setupServer(...handlers)\n\n// Enable API mocking before tests.\nbeforeAll(() => server.listen())\n\n// Reset any runtime request handlers we may add during the tests.\nafterEach(() => server.resetHandlers())\n\n// Disable API mocking after the tests are done.\nafterAll(() => server.close())\n\ntest('fetches & receives a user after clicking the fetch user button', async () => {\n  renderWithProviders(<UserDisplay />)\n\n  // should show no user initially, and not be fetching a user\n  expect(screen.getByText(/no user/i)).toBeInTheDocument()\n  expect(screen.queryByText(/Fetching user\\.\\.\\./i)).not.toBeInTheDocument()\n\n  // after clicking the 'Fetch user' button, it should now show that it is fetching the user\n  fireEvent.click(screen.getByRole('button', { name: /Fetch user/i }))\n  expect(screen.getByText(/no user/i)).toBeInTheDocument()\n\n  // after some time, the user should be received\n  expect(await screen.findByText(/John Smith/i)).toBeInTheDocument()\n  expect(screen.queryByText(/no user/i)).not.toBeInTheDocument()\n  expect(screen.queryByText(/Fetching user\\.\\.\\./i)).not.toBeInTheDocument()\n})\n")),(0,s.kt)("p",null,"In this test, ",(0,s.kt)("strong",{parentName:"p"},"we have completely avoided testing any Redux code directly, treating it as an implementation detail"),". As a result, we are free to re-factor the ",(0,s.kt)("em",{parentName:"p"},"implementation"),", while our tests will continue to pass and avoid false negatives (tests that fail despite the app still behaving how we want it to). We might change our state structure, convert our slice to use ",(0,s.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/rtk-query/overview"},"RTK-Query"),", or remove Redux entirely, and our tests will still pass. We have a strong degree of confidence that if we change some code and our tests report a failure, then our app really ",(0,s.kt)("em",{parentName:"p"},"is")," broken."),(0,s.kt)("h3",{id:"preparing-initial-test-state"},"Preparing Initial Test State"),(0,s.kt)("p",null,"Many tests require that certain pieces of state already exist in the Redux store before the component is rendered. With the custom render function, there are a couple different ways you can do that."),(0,s.kt)("p",null,"One option is to pass a ",(0,s.kt)("inlineCode",{parentName:"p"},"preloadedState")," argument in to the custom render function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="TodoList.test.tsx" no-transpile',title:'"TodoList.test.tsx"',"no-transpile":!0},"test('Uses preloaded state to render', () => {\n  const initialTodos = [{ id: 5, text: 'Buy Milk', completed: false }]\n\n  const { getByText } = renderWithProviders(<TodoList />, {\n    preloadedState: {\n      todos: initialTodos\n    }\n  })\n})\n")),(0,s.kt)("p",null,"Another option is to create a custom Redux store first and dispatch some actions to build up the desired state, then pass in that specific store instance:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="TodoList.test.tsx" no-transpile',title:'"TodoList.test.tsx"',"no-transpile":!0},"test('Sets up initial state state with actions', () => {\n  const store = setupStore()\n  store.dispatch(todoAdded('Buy milk'))\n\n  const { getByText } = renderWithProviders(<TodoList />, { store })\n})\n")),(0,s.kt)("p",null,"You can also extract ",(0,s.kt)("inlineCode",{parentName:"p"},"store")," from the object returned by the custom render function, and dispatch more actions later as part of the test."),(0,s.kt)("h2",{id:"unit-testing-individual-functions"},"Unit Testing Individual Functions"),(0,s.kt)("p",null,"While we recommend using integration tests by default, since they exercise all the Redux logic working together, you may sometimes want to write unit tests for individual functions as well."),(0,s.kt)("h3",{id:"reducers"},"Reducers"),(0,s.kt)("p",null,"Reducers are pure functions that return the new state after applying the action to the previous state. In the majority of cases, the reducer is an implementation detail that does not need explicit tests. However, if your reducer contains particularly complex logic that you would like the confidence of having unit tests for, reducers can be easily tested."),(0,s.kt)("p",null,"Because reducers are pure functions, so testing them should be straightforward. Call the reducer with a specific input ",(0,s.kt)("inlineCode",{parentName:"p"},"state")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"action"),", and assert that the result state matches expectations."),(0,s.kt)("h4",{id:"example"},"Example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nexport type Todo = {\n  id: number\n  text: string\n  completed: boolean\n}\n\nconst initialState: Todo[] = [{ text: 'Use Redux', completed: false, id: 0 }]\n\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    todoAdded(state, action: PayloadAction<string>) {\n      state.push({\n        id: state.reduce((maxId, todo) => Math.max(todo.id, maxId), -1) + 1,\n        completed: false,\n        text: action.payload\n      })\n    }\n  }\n})\n\nexport const { todoAdded } = todosSlice.actions\n\nexport default todosSlice.reducer\n")),(0,s.kt)("p",null,"can be tested like:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// file: todosSlice.ts noEmit\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit'\nexport type Todo = {\n  id: number\n  text: string\n  completed: boolean\n}\nconst initialState: Todo[] = [\n  {\n    text: 'Use Redux',\n    completed: false,\n    id: 0\n  }\n]\nconst todosSlice = createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    todoAdded(state, action: PayloadAction<string>) {\n      state.push({\n        id: state.reduce((maxId, todo) => Math.max(todo.id, maxId), -1) + 1,\n        completed: false,\n        text: action.payload\n      })\n    }\n  }\n})\nexport const { todoAdded } = todosSlice.actions\nexport default todosSlice.reducer\n\n// file: todosSlice.test.ts\n\nimport reducer, { todoAdded, Todo } from './todosSlice'\n\ntest('should return the initial state', () => {\n  expect(reducer(undefined, { type: undefined })).toEqual([\n    { text: 'Use Redux', completed: false, id: 0 }\n  ])\n})\n\ntest('should handle a todo being added to an empty list', () => {\n  const previousState: Todo[] = []\n\n  expect(reducer(previousState, todoAdded('Run the tests'))).toEqual([\n    { text: 'Run the tests', completed: false, id: 0 }\n  ])\n})\n\ntest('should handle a todo being added to an existing list', () => {\n  const previousState: Todo[] = [\n    { text: 'Run the tests', completed: true, id: 0 }\n  ]\n\n  expect(reducer(previousState, todoAdded('Use Redux'))).toEqual([\n    { text: 'Run the tests', completed: true, id: 0 },\n    { text: 'Use Redux', completed: false, id: 1 }\n  ])\n})\n")),(0,s.kt)("h3",{id:"selectors"},"Selectors"),(0,s.kt)("p",null,"Selectors are also generally pure functions, and thus can be tested using the same basic approach as reducers: set up an initial value, call the selector function with those inputs, and assert that the result matches the expected output."),(0,s.kt)("p",null,"However, since ",(0,s.kt)("a",{parentName:"p",href:"/usage/deriving-data-selectors"},"most selectors are memoized to remember their last inputs"),", you may need to watch for cases where a selector is returning a cached value when you expected it to generate a new one depending on where it's being used in the test."),(0,s.kt)("h3",{id:"action-creators--thunks"},"Action Creators & Thunks"),(0,s.kt)("p",null,"In Redux, action creators are functions which return plain objects. Our recommendation is not to write action creators manually, but instead have them generated automatically by ",(0,s.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createSlice#return-value"},(0,s.kt)("inlineCode",{parentName:"a"},"createSlice")),", or created via ",(0,s.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createAction"},(0,s.kt)("inlineCode",{parentName:"a"},"createAction"))," from ",(0,s.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/introduction/getting-started"},(0,s.kt)("inlineCode",{parentName:"a"},"@reduxjs/toolkit")),". As such, ",(0,s.kt)("strong",{parentName:"p"},"you should not feel the need to test action creators by themselves")," (the Redux Toolkit maintainers have already done that for you!)."),(0,s.kt)("p",null,"The return value of action creators is considered an implementation detail within your application, and when following an integration testing style, do not need explicit tests."),(0,s.kt)("p",null,"Similarly for thunks using ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-thunk"},"Redux Thunk"),", our recommendation is not to write them manually, but instead use ",(0,s.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createAsyncThunk"},(0,s.kt)("inlineCode",{parentName:"a"},"createAsyncThunk"))," from ",(0,s.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/introduction/getting-started"},(0,s.kt)("inlineCode",{parentName:"a"},"@reduxjs/toolkit")),". The thunk handles dispatching the appropriate ",(0,s.kt)("inlineCode",{parentName:"p"},"pending"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"fulfilled")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"rejected")," action types for you based on the lifecycle of the thunk."),(0,s.kt)("p",null,"We consider thunk behavior to be an implementation detail of the application, and recommend that it be covered by testing the group of components (or whole app) using it, rather than testing the thunk in isolation."),(0,s.kt)("p",null,"Our recommendation is to mock async requests at the ",(0,s.kt)("inlineCode",{parentName:"p"},"fetch/xhr")," level using tools like ",(0,s.kt)("a",{parentName:"p",href:"https://mswjs.io/"},(0,s.kt)("inlineCode",{parentName:"a"},"msw")),", ",(0,s.kt)("a",{parentName:"p",href:"https://miragejs.com/"},(0,s.kt)("inlineCode",{parentName:"a"},"miragejs")),", ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/jefflau/jest-fetch-mock#readme"},(0,s.kt)("inlineCode",{parentName:"a"},"jest-fetch-mock")),", ",(0,s.kt)("a",{parentName:"p",href:"https://www.wheresrhys.co.uk/fetch-mock/"},(0,s.kt)("inlineCode",{parentName:"a"},"fetch-mock")),', or similar. By mocking requests at this level, none of the thunk logic has to change in a test - the thunk still tries to make a "real" async request, it just gets intercepted. See the ',(0,s.kt)("a",{parentName:"p",href:"#writing-integration-tests-with-components"},'"Integration Test" example')," for an example of testing a component which internally includes the behavior of a thunk."),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"If you prefer, or are otherwise required to write unit tests for your action creators or thunks, refer to the tests that Redux Toolkit uses for ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-toolkit/blob/635d6d5e513e13dd59cd717f600d501b30ca2381/src/tests/createAction.test.ts"},(0,s.kt)("inlineCode",{parentName:"a"},"createAction"))," and ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-toolkit/blob/635d6d5e513e13dd59cd717f600d501b30ca2381/src/tests/createAsyncThunk.test.ts"},(0,s.kt)("inlineCode",{parentName:"a"},"createAsyncThunk")),"."))),(0,s.kt)("h3",{id:"middleware"},"Middleware"),(0,s.kt)("p",null,"Middleware functions wrap behavior of ",(0,s.kt)("inlineCode",{parentName:"p"},"dispatch")," calls in Redux, so to test this modified behavior we need to mock the behavior of the ",(0,s.kt)("inlineCode",{parentName:"p"},"dispatch")," call."),(0,s.kt)("h4",{id:"example-1"},"Example"),(0,s.kt)("p",null,"First, we'll need a middleware function. This is similar to the real ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-thunk/blob/master/src/index.ts"},"redux-thunk"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const thunkMiddleware =\n  ({ dispatch, getState }) =>\n  next =>\n  action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState)\n    }\n\n    return next(action)\n  }\n")),(0,s.kt)("p",null,"We need to create fake ",(0,s.kt)("inlineCode",{parentName:"p"},"getState"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"dispatch"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"next")," functions. We use ",(0,s.kt)("inlineCode",{parentName:"p"},"jest.fn()")," to create stubs, but with other test frameworks you would likely use ",(0,s.kt)("a",{parentName:"p",href:"https://sinonjs.org/"},"Sinon"),"."),(0,s.kt)("p",null,"The invoke function runs our middleware in the same way Redux does."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const create = () => {\n  const store = {\n    getState: jest.fn(() => ({})),\n    dispatch: jest.fn()\n  }\n  const next = jest.fn()\n\n  const invoke = action => thunkMiddleware(store)(next)(action)\n\n  return { store, next, invoke }\n}\n")),(0,s.kt)("p",null,"We test that our middleware is calling the ",(0,s.kt)("inlineCode",{parentName:"p"},"getState"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"dispatch"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"next")," functions at the right time."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"test('passes through non-function action', () => {\n  const { next, invoke } = create()\n  const action = { type: 'TEST' }\n  invoke(action)\n  expect(next).toHaveBeenCalledWith(action)\n})\n\ntest('calls the function', () => {\n  const { invoke } = create()\n  const fn = jest.fn()\n  invoke(fn)\n  expect(fn).toHaveBeenCalled()\n})\n\ntest('passes dispatch and getState', () => {\n  const { store, invoke } = create()\n  invoke((dispatch, getState) => {\n    dispatch('TEST DISPATCH')\n    getState()\n  })\n  expect(store.dispatch).toHaveBeenCalledWith('TEST DISPATCH')\n  expect(store.getState).toHaveBeenCalled()\n})\n")),(0,s.kt)("p",null,"In some cases, you will need to modify the ",(0,s.kt)("inlineCode",{parentName:"p"},"create")," function to use different mock implementations of ",(0,s.kt)("inlineCode",{parentName:"p"},"getState")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"next"),"."),(0,s.kt)("h2",{id:"further-information"},"Further Information"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://testing-library.com/docs/react-testing-library/intro"},"React Testing Library"),': React Testing Library is a very light-weight solution for testing React components. It provides light utility functions on top of react-dom and react-dom/test-utils, in a way that encourages better testing practices. Its primary guiding principle is: "The more your tests resemble the way your software is used, the more confidence they can give you."'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://reactjs.org/docs/test-utils.html"},"React Test Utils"),": ReactTestUtils makes it easy to test React components in the testing framework of your choice. React Testing Library uses the ",(0,s.kt)("inlineCode",{parentName:"li"},"act")," function exported by React Test Utils."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2021/06/the-evolution-of-redux-testing-approaches/"},"Blogged Answers: The Evolution of Redux Testing Approaches"),": Mark Erikson's thoughts on how Redux testing has evolved from 'isolation' to 'integration'."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://kentcdodds.com/blog/testing-implementation-details"},"Testing Implementation Details"),": Blog post by Kent C. Dodds on why he recommends to avoid testing implementation details.")))}m.isMDXComponent=!0}}]);